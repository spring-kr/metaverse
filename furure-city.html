<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ™ï¸ ë¯¸ë˜ ë„ì‹œ - ë„ê¹¨ë¹„ ë©”íƒ€ë²„ìŠ¤</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0f1419 0%, #1a252f 50%, #2c3e50 100%);
            color: white;
            overflow: hidden;
        }
        
        #future-city-canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            cursor: crosshair;
        }
        
        /* ë©”ì¸ UI ì»¨í…Œì´ë„ˆ */
        .ui-container {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
            pointer-events: none;
        }
        
        .ui-container > * {
            pointer-events: auto;
        }
        
        /* ìƒíƒœ í‘œì‹œ */
        .status-display {
            background: rgba(15, 20, 25, 0.9);
            border: 2px solid #00ff88;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            font-size: 14px;
            backdrop-filter: blur(10px);
            box-shadow: 0 5px 15px rgba(0, 255, 136, 0.3);
        }
        
        /* ì»¨íŠ¸ë¡¤ íŒ¨ë„ */
        .control-panel {
            background: rgba(15, 20, 25, 0.95);
            border: 2px solid #00ff88;
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 5px 20px rgba(0, 255, 136, 0.4);
            min-width: 300px;
        }
        
        .control-btn {
            background: linear-gradient(135deg, #00ff88 0%, #00cc6a 100%);
            border: none;
            border-radius: 8px;
            color: #0f1419;
            padding: 12px 16px;
            margin: 5px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.3s ease;
            width: 100%;
            text-align: center;
        }
        
        .control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 255, 136, 0.4);
        }
        
        /* ë’¤ë¡œê°€ê¸° ë²„íŠ¼ */
        .back-btn {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1001;
            border: none;
            border-radius: 10px;
            color: white;
            padding: 15px 20px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        .back-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.4);
        }
        
        /* ë¯¸ë˜ ë„ê¹¨ë¹„ ì¹´ë“œ */
        .future-goblin-card {
            background: rgba(15, 20, 25, 0.9);
            border: 2px solid #00ff88;
            border-radius: 15px;
            padding: 15px;
            margin: 10px 0;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }
        
        .future-goblin-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0, 255, 136, 0.3);
            border-color: #00ffaa;
        }
        
        .goblin-name {
            font-size: 18px;
            font-weight: bold;
            color: #00ff88;
            margin-bottom: 8px;
        }
        
        .goblin-specialty {
            font-size: 14px;
            color: #00ffaa;
            margin-bottom: 5px;
        }

        /* ğŸ™ï¸ ë¯¸ë˜ ì±„íŒ… ì‹œìŠ¤í…œ */
        .chat-container {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 350px;
            height: 500px;
            background: linear-gradient(135deg, rgba(15, 20, 25, 0.95), rgba(0, 255, 136, 0.1));
            border: 2px solid #00ff88;
            border-radius: 15px;
            display: none;
            flex-direction: column;
            backdrop-filter: blur(15px);
            box-shadow: 0 10px 30px rgba(0, 255, 136, 0.3);
            z-index: 1000;
        }

        .chat-header {
            background: linear-gradient(90deg, #0a0f14, #00ff88);
            color: white;
            padding: 15px;
            border-radius: 13px 13px 0 0;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #00ff88;
        }

        .chat-close {
            background: none;
            border: none;
            color: #00ff88;
            font-size: 20px;
            cursor: pointer;
            padding: 0;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            transition: all 0.3s ease;
        }

        .chat-close:hover {
            background: rgba(0, 255, 136, 0.2);
        }

        .chat-messages {
            flex: 1;
            padding: 15px;
            overflow-y: auto;
            background: rgba(15, 20, 25, 0.8);
        }

        .message {
            margin: 10px 0;
            display: flex;
            align-items: flex-start;
            gap: 10px;
        }

        .message.user-message {
            flex-direction: row-reverse;
        }

        .message .avatar {
            min-width: 35px;
            height: 35px;
            border-radius: 50%;
            background: linear-gradient(135deg, #00ff88, #00ffaa);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            color: #0a0f14;
        }

        .message.user-message .avatar {
            background: linear-gradient(135deg, #00cc66, #00ff99);
        }

        .message .text {
            background: rgba(0, 255, 136, 0.2);
            padding: 10px 15px;
            border-radius: 15px;
            max-width: 250px;
            word-wrap: break-word;
            border: 1px solid rgba(0, 255, 136, 0.3);
            color: #e0fff0;
        }

        .message.user-message .text {
            background: rgba(0, 255, 170, 0.2);
            border-color: rgba(0, 255, 170, 0.3);
        }

        .chat-input-container {
            padding: 15px;
            border-top: 1px solid rgba(0, 255, 136, 0.3);
            background: rgba(15, 20, 25, 0.9);
            border-radius: 0 0 13px 13px;
        }

        .chat-input {
            width: 100%;
            padding: 10px;
            border: 2px solid #00ff88;
            border-radius: 20px;
            background: rgba(15, 20, 25, 0.8);
            color: #e0fff0;
            font-size: 14px;
            outline: none;
            transition: all 0.3s ease;
        }

        .chat-input:focus {
            border-color: #00ffaa;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
        }

        .chat-input::placeholder {
            color: #00ffaa;
        }
    </style>
</head>
<body>
    <!-- ë’¤ë¡œê°€ê¸° ë²„íŠ¼ -->
    <button class="back-btn" onclick="goBackToVillage()">â† ğŸ˜ï¸ ë„ê¹¨ë¹„ ë§ˆì„ë¡œ</button>
    
    <!-- ë©”ì¸ ìº”ë²„ìŠ¤ -->
    <canvas id="future-city-canvas"></canvas>
    
    <!-- UI ì»¨í…Œì´ë„ˆ -->
    <div class="ui-container">
        <!-- ìƒíƒœ í‘œì‹œ -->
        <div class="status-display" id="statusDisplay">
            ğŸ™ï¸ ë¯¸ë˜ ë„ì‹œì— ì˜¤ì‹  ê²ƒì„ í™˜ì˜í•©ë‹ˆë‹¤!
        </div>
        
        <!-- ğŸ™ï¸ ì±„íŒ… ì‹œìŠ¤í…œ -->
        <div class="chat-container" id="chatContainer">
            <div class="chat-header">
                <span id="chatTitle">ğŸ™ï¸ ë¯¸ë˜ ë„ê¹¨ë¹„ì™€ì˜ ëŒ€í™”</span>
                <button class="chat-close" onclick="closeChat()">Ã—</button>
            </div>
            <div class="chat-messages" id="chatMessages"></div>
            <div class="chat-input-container">
                <input type="text" class="chat-input" id="chatInput" 
                       placeholder="ë¯¸ë˜ ê¸°ìˆ ì— ëŒ€í•´ ì§ˆë¬¸í•´ë³´ì„¸ìš”..." 
                       onkeypress="handleChatKeyPress(event)">
            </div>
        </div>
        
        <!-- ì»¨íŠ¸ë¡¤ íŒ¨ë„ -->
        <div class="control-panel">
            <h2 style="color: #00ff88; margin-bottom: 15px; text-align: center;">ğŸ™ï¸ ë¯¸ë˜ ë„ì‹œ</h2>
            
            <div style="margin-bottom: 20px;">
                <h3 style="color: #00ff88; margin-bottom: 10px; font-size: 16px;">ğŸ® ì»¨íŠ¸ë¡¤</h3>
                <button class="control-btn" onclick="toggleAvatar()">ğŸ¤– ì‚¬ì´ë²„ ì•„ë°”íƒ€</button>
                <button class="control-btn" onclick="resetCamera()">ğŸ“· ì¹´ë©”ë¼ ë¦¬ì…‹</button>
                <button class="control-btn" onclick="toggleDistrict()">ğŸŒ† êµ¬ì—­ ë³€ê²½</button>
            </div>
            
            <div style="margin-bottom: 20px;">
                <h3 style="color: #00ff88; margin-bottom: 10px; font-size: 16px;">ğŸ¤– ë¯¸ë˜ ë„ê¹¨ë¹„ë“¤</h3>
                <div id="futureGoblinGrid">
                    <!-- ë¯¸ë˜ ë„ê¹¨ë¹„ë“¤ì´ ì—¬ê¸°ì— ìƒì„±ë©ë‹ˆë‹¤ -->
                </div>
            </div>
        </div>
    </div>
    
    <!-- Three.js ë° GSAP ë¼ì´ë¸ŒëŸ¬ë¦¬ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    
    <script>
        // ğŸ™ï¸ ë¯¸ë˜ ë„ì‹œ ì „ì—­ ë³€ìˆ˜
        let scene, camera, renderer, controls;
        let currentChatGoblin = null; // ğŸ™ï¸ í˜„ì¬ ì±„íŒ… ì¤‘ì¸ ë„ê¹¨ë¹„
        let avatar = null;
        let isSystemReady = false;
        
        // ğŸ¤– ë¯¸ë˜ì˜ ë„ê¹¨ë¹„ë“¤
        const futureGoblins = [
            { name: 'ğŸ¤– AI ê°œë°œì', specialty: 'ì¸ê³µì§€ëŠ¥', description: 'ì°¨ì„¸ëŒ€ AI ì‹œìŠ¤í…œì„ ì„¤ê³„í•˜ëŠ” ë„ê¹¨ë¹„', emoji: 'ğŸ¤–', color: 0x00ff88 },
            { name: 'ğŸš ë“œë¡  ì¡°ì¢…ì‚¬', specialty: 'ë¬´ì¸ í•­ê³µ', description: 'ìŠ¤ë§ˆíŠ¸ ë“œë¡  ì‹œìŠ¤í…œì„ ê´€ë¦¬í•˜ëŠ” ë„ê¹¨ë¹„', emoji: 'ğŸš', color: 0x3498db },
            { name: 'ğŸŒ ë„¤íŠ¸ì›Œí¬ ë§ˆë²•ì‚¬', specialty: 'ì´ˆì—°ê²°ì„±', description: 'ë¯¸ë˜ ë„¤íŠ¸ì›Œí¬ë¥¼ êµ¬ì¶•í•˜ëŠ” ë„ê¹¨ë¹„', emoji: 'ğŸŒ', color: 0x9b59b6 },
            { name: 'âš¡ ì—ë„ˆì§€ ì—”ì§€ë‹ˆì–´', specialty: 'ì‹ ì¬ìƒ ì—ë„ˆì§€', description: 'ë¬´í•œ ì—ë„ˆì§€ë¥¼ ì—°êµ¬í•˜ëŠ” ë„ê¹¨ë¹„', emoji: 'âš¡', color: 0xf1c40f },
            { name: 'ğŸ›¸ ìš°ì£¼ íƒí—˜ê°€', specialty: 'ìš°ì£¼ ì—¬í–‰', description: 'ì€í•˜ê³„ë¥¼ íƒí—˜í•˜ëŠ” ëª¨í—˜ê°€ ë„ê¹¨ë¹„', emoji: 'ğŸ›¸', color: 0xe74c3c },
            { name: 'ğŸ”¬ ë‚˜ë…¸ ê³¼í•™ì', specialty: 'ë‚˜ë…¸ ê¸°ìˆ ', description: 'ë¶„ì ìˆ˜ì¤€ì—ì„œ ì‘ì—…í•˜ëŠ” ë„ê¹¨ë¹„', emoji: 'ğŸ”¬', color: 0x2ecc71 }
        ];
        
        // ğŸ¯ ìƒíƒœ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
        function updateStatus(message) {
            const statusElement = document.getElementById('statusDisplay');
            if (statusElement) {
                statusElement.textContent = message;
            }
        }
        
        // ğŸ”™ ë„ê¹¨ë¹„ ë§ˆì„ë¡œ ëŒì•„ê°€ê¸°
        function goBackToVillage() {
            updateStatus('ğŸ˜ï¸ ë„ê¹¨ë¹„ ë§ˆì„ë¡œ ëŒì•„ê°€ëŠ” ì¤‘...');
            // GitHub Pagesìš© ë² ì´ìŠ¤ URL ê³„ì‚°
            const baseURL = window.location.origin + window.location.pathname.replace(/\/[^\/]*$/, '/');
            setTimeout(() => {
                window.location.href = baseURL + 'index.html';
            }, 1000);
        }
        
        // ğŸ® ì•„ë°”íƒ€ í† ê¸€
        function toggleAvatar() {
            if (!avatar) {
                createAvatar();
            } else {
                removeAvatar();
            }
        }
        
        // ğŸ¤– ì‚¬ì´ë²„ ì•„ë°”íƒ€ ìƒì„±
        function createAvatar() {
            avatar = new THREE.Group();
            
            // ì‚¬ì´ë²„ ìŠˆíŠ¸ (ë°ì€ ì²­ìƒ‰)
            const bodyGeometry = new THREE.CylinderGeometry(0.5, 0.7, 2.2);
            const bodyMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x1a252f,
                emissive: 0x00ff88,
                emissiveIntensity: 0.3,
                shininess: 100
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 1.1;
            avatar.add(body);
            
            // ì‚¬ì´ë²„ í—¬ë©§ ë¨¸ë¦¬
            const headGeometry = new THREE.SphereGeometry(0.5);
            const headMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x0f1419,
                emissive: 0x00ff88,
                emissiveIntensity: 0.4,
                shininess: 100
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 2.7;
            avatar.add(head);
            
            // í™€ë¡œê·¸ë¨ ë°”ì´ì €
            const visorGeometry = new THREE.RingGeometry(0.3, 0.45, 16);
            const visorMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00ffaa,
                transparent: true,
                opacity: 0.7,
                side: THREE.DoubleSide
            });
            const visor = new THREE.Mesh(visorGeometry, visorMaterial);
            visor.position.set(0, 2.7, 0.5);
            avatar.add(visor);
            
            // ì—ë„ˆì§€ ì½”ì–´ (ê°€ìŠ´)
            const coreGeometry = new THREE.SphereGeometry(0.15);
            const coreMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00ff88,
                emissive: 0x00ff88,
                emissiveIntensity: 0.8
            });
            const core = new THREE.Mesh(coreGeometry, coreMaterial);
            core.position.set(0, 1.8, 0.5);
            avatar.add(core);
            
            // ì‚¬ì´ë²„ íŒ” (ì˜¤ë¥¸ìª½)
            const armGeometry = new THREE.CylinderGeometry(0.1, 0.15, 1.5);
            const armMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x1a252f,
                emissive: 0x00ff88,
                emissiveIntensity: 0.2
            });
            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(0.8, 1.5, 0);
            rightArm.rotation.z = 0.3;
            avatar.add(rightArm);
            
            // í™€ë¡œê·¸ë¨ ë””ìŠ¤í”Œë ˆì´ (ì™¼ì†)
            const holoGeometry = new THREE.PlaneGeometry(0.6, 0.4);
            const holoMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00ffaa,
                transparent: true,
                opacity: 0.6,
                side: THREE.DoubleSide
            });
            const holo = new THREE.Mesh(holoGeometry, holoMaterial);
            holo.position.set(-0.8, 1.8, 0);
            holo.rotation.y = 0.3;
            avatar.add(holo);
            
            // ì‚¬ì´ë²„ ì˜¤ë¼ (ì›í˜• ì—ë„ˆì§€ í•„ë“œë“¤)
            for (let i = 0; i < 5; i++) {
                const auraGeometry = new THREE.RingGeometry(0.8 + i * 0.4, 1.2 + i * 0.4, 20);
                const auraMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x00ff88,
                    transparent: true,
                    opacity: 0.3 - i * 0.04,
                    side: THREE.DoubleSide
                });
                const aura = new THREE.Mesh(auraGeometry, auraMaterial);
                aura.rotation.x = -Math.PI / 2;
                aura.position.y = 0.1;
                avatar.add(aura);
                
                gsap.to(aura.rotation, {
                    z: Math.PI * 2,
                    duration: 4 - i * 0.3,
                    repeat: -1,
                    ease: "none"
                });
            }
            
            // ì—ë„ˆì§€ ì½”ì–´ í„ìŠ¤ ì• ë‹ˆë©”ì´ì…˜
            gsap.to(core.scale, {
                x: 1.5, y: 1.5, z: 1.5,
                duration: 1.5,
                repeat: -1,
                yoyo: true,
                ease: "sine.inOut"
            });
            
            // ë°”ì´ì € ê¹œë¹¡ì„
            gsap.to(visor.material, {
                opacity: 0.3,
                duration: 2,
                repeat: -1,
                yoyo: true,
                ease: "sine.inOut"
            });
            
            avatar.position.set(0, 0, 0);
            scene.add(avatar);
            
            if (camera && controls) {
                gsap.to(camera.position, {
                    x: 6, y: 10, z: 15,
                    duration: 1.5,
                    ease: "power2.out"
                });
                gsap.to(controls.target, {
                    x: 0, y: 1, z: 0,
                    duration: 1.5,
                    ease: "power2.out",
                    onUpdate: () => controls.update()
                });
            }
            
            updateStatus('ğŸ¤– ì‚¬ì´ë²„ ì•„ë°”íƒ€ê°€ ë¯¸ë˜ ëª¨ë“œë¡œ í™œì„±í™”ë˜ì—ˆìŠµë‹ˆë‹¤!');
        }
        
        // ğŸ¤– ì•„ë°”íƒ€ ì œê±°
        function removeAvatar() {
            if (avatar) {
                while(avatar.children.length > 0) {
                    const child = avatar.children[0];
                    avatar.remove(child);
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                }
                scene.remove(avatar);
                avatar = null;
                updateStatus('ğŸ‘‹ ì‚¬ì´ë²„ ì•„ë°”íƒ€ê°€ ì‹œìŠ¤í…œì—ì„œ ë¡œê·¸ì•„ì›ƒí–ˆìŠµë‹ˆë‹¤');
            }
        }
        
        // ğŸ“· ì¹´ë©”ë¼ ë¦¬ì…‹
        function resetCamera() {
            if (camera && controls) {
                gsap.to(camera.position, {
                    x: 0, y: 25, z: 35,
                    duration: 1.5,
                    ease: "power2.out"
                });
                gsap.to(controls.target, {
                    x: 0, y: 0, z: 0,
                    duration: 1.5,
                    ease: "power2.out",
                    onUpdate: () => controls.update()
                });
                updateStatus('ğŸ“· ì¹´ë©”ë¼ê°€ ë¯¸ë˜ ë„ì‹œ ì¤‘ì•™ìœ¼ë¡œ ë¦¬ì…‹ë˜ì—ˆìŠµë‹ˆë‹¤');
            }
        }
        
        // ğŸŒ† êµ¬ì—­ ë³€ê²½
        function toggleDistrict() {
            const districts = ['ğŸ¢ ë¹„ì¦ˆë‹ˆìŠ¤ íƒ€ì›Œ', 'ğŸ¤– AI ì—°êµ¬ì†Œ', 'ğŸš ë“œë¡  í—ˆë¸Œ', 'âš¡ ì—ë„ˆì§€ ì„¼í„°', 'ğŸ›¸ ìš°ì£¼ í¬íŠ¸'];
            const randomDistrict = districts[Math.floor(Math.random() * districts.length)];
            updateStatus(`ğŸŒ† í˜„ì¬ ìœ„ì¹˜: ${randomDistrict}`);
        }
        
        // ğŸ·ï¸ ë¯¸ë˜ ë„ê¹¨ë¹„ ì´ë¦„í‘œ ìƒì„±
        function createFutureGoblinNameTag(name, specialty) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 256;
            
            // ì‚¬ì´ë²„ ë°°ê²½ ê·¸ë¼ë””ì–¸íŠ¸
            const gradient = context.createLinearGradient(0, 0, canvas.width, canvas.height);
            gradient.addColorStop(0, 'rgba(15, 20, 25, 0.95)');
            gradient.addColorStop(0.5, 'rgba(26, 37, 47, 0.9)');
            gradient.addColorStop(1, 'rgba(44, 62, 80, 0.95)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            // ë„¤ì˜¨ í…Œë‘ë¦¬
            context.strokeStyle = '#00ff88';
            context.lineWidth = 4;
            context.strokeRect(2, 2, canvas.width - 4, canvas.height - 4);
            
            // ë‚´ë¶€ ë„¤ì˜¨ í…Œë‘ë¦¬
            context.strokeStyle = '#00ffaa';
            context.lineWidth = 2;
            context.strokeRect(12, 12, canvas.width - 24, canvas.height - 24);
            
            // ì´ë¦„ í…ìŠ¤íŠ¸ (ì‚¬ì´ë²„ í°íŠ¸)
            context.shadowColor = '#00ff88';
            context.shadowBlur = 10;
            context.fillStyle = '#00ff88';
            context.font = 'bold 38px monospace';
            context.textAlign = 'center';
            context.fillText(name, canvas.width / 2, 80);
            
            // ì „ë¬¸ ë¶„ì•¼ í…ìŠ¤íŠ¸
            context.shadowBlur = 6;
            context.fillStyle = '#00ffaa';
            context.font = '26px monospace';
            context.fillText(specialty, canvas.width / 2, 130);
            
            // ì‚¬ì´ë²„ íšŒë¡œ ë¼ì¸ë“¤
            context.shadowBlur = 0;
            context.strokeStyle = '#00ff88';
            context.lineWidth = 2;
            
            // ìˆ˜í‰ ë¼ì¸
            context.beginPath();
            context.moveTo(50, 150);
            context.lineTo(canvas.width - 50, 150);
            context.stroke();
            
            // íšŒë¡œ íŒ¨í„´
            for (let i = 0; i < 8; i++) {
                const x = 80 + i * 50;
                const y = 190;
                
                // íšŒë¡œ ì¹©ë“¤
                context.fillStyle = '#00ff88';
                context.fillRect(x - 10, y - 8, 20, 16);
                
                // ë‚´ë¶€ íšŒë¡œ
                context.fillStyle = '#0f1419';
                context.fillRect(x - 6, y - 4, 12, 8);
                
                // ì—°ê²°ì„ ë“¤
                if (i < 7) {
                    context.strokeStyle = '#00ffaa';
                    context.lineWidth = 1;
                    context.beginPath();
                    context.moveTo(x + 10, y);
                    context.lineTo(x + 40, y);
                    context.stroke();
                }
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            
            const planeGeometry = new THREE.PlaneGeometry(4, 2);
            const planeMaterial = new THREE.MeshBasicMaterial({ 
                map: texture, 
                transparent: true,
                side: THREE.DoubleSide
            });
            
            const nameTagMesh = new THREE.Mesh(planeGeometry, planeMaterial);
            nameTagMesh.userData.isNameTag = true;
            
            return nameTagMesh;
        }
        
        // ğŸ¤– 3D ë¯¸ë˜ ë„ê¹¨ë¹„ë“¤ ìƒì„±
        function createFuture3DGoblins() {
            futureGoblins.forEach((goblin, index) => {
                const goblin3D = createFuture3DGoblin(goblin, index);
                scene.add(goblin3D);
            });
        }
        
        // ğŸ¤– ê°œë³„ 3D ë¯¸ë˜ ë„ê¹¨ë¹„ ìƒì„±
        function createFuture3DGoblin(goblinData, index) {
            const goblinGroup = new THREE.Group();
            
            // ì‚¬ì´ë²„ ìŠˆíŠ¸ ëª¸ì²´
            const bodyGeometry = new THREE.CylinderGeometry(0.8, 1.2, 2.5);
            const bodyMaterial = new THREE.MeshPhongMaterial({ 
                color: goblinData.color,
                emissive: goblinData.color,
                emissiveIntensity: 0.2,
                shininess: 100
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 1.25;
            goblinGroup.add(body);
            
            // ì‚¬ì´ë²„ í—¬ë©§ ë¨¸ë¦¬
            const headGeometry = new THREE.SphereGeometry(0.7);
            const headMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x0f1419,
                emissive: goblinData.color,
                emissiveIntensity: 0.3,
                shininess: 100
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 3.2;
            goblinGroup.add(head);
            
            // í™€ë¡œê·¸ë¨ ë°”ì´ì €
            const visorGeometry = new THREE.RingGeometry(0.4, 0.6, 16);
            const visorMaterial = new THREE.MeshBasicMaterial({ 
                color: goblinData.color,
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide
            });
            const visor = new THREE.Mesh(visorGeometry, visorMaterial);
            visor.position.set(0, 3.2, 0.6);
            goblinGroup.add(visor);
            
            // ì—ë„ˆì§€ ì½”ì–´
            const coreGeometry = new THREE.SphereGeometry(0.2);
            const coreMaterial = new THREE.MeshBasicMaterial({ 
                color: goblinData.color,
                emissive: goblinData.color,
                emissiveIntensity: 1
            });
            const core = new THREE.Mesh(coreGeometry, coreMaterial);
            core.position.set(0, 1.8, 0.6);
            goblinGroup.add(core);
            
            // ë– ë‹¤ë‹ˆëŠ” í™€ë¡œê·¸ë¨ íŒ¨ë„ë“¤
            for (let i = 0; i < 8; i++) {
                const panelGeometry = new THREE.PlaneGeometry(0.4, 0.3);
                const panelMaterial = new THREE.MeshBasicMaterial({ 
                    color: goblinData.color,
                    transparent: true,
                    opacity: 0.7,
                    side: THREE.DoubleSide
                });
                const panel = new THREE.Mesh(panelGeometry, panelMaterial);
                
                const angle = (i / 8) * Math.PI * 2;
                panel.position.set(
                    Math.cos(angle) * 2.5,
                    3 + Math.sin(i) * 0.8,
                    Math.sin(angle) * 2.5
                );
                panel.rotation.y = angle + Math.PI / 2;
                goblinGroup.add(panel);
                
                // í™€ë¡œê·¸ë¨ íšŒì „ ì• ë‹ˆë©”ì´ì…˜
                gsap.to(panel.rotation, {
                    y: panel.rotation.y + Math.PI * 2,
                    duration: 6 + i * 0.3,
                    repeat: -1,
                    ease: "none"
                });
                
                // í™€ë¡œê·¸ë¨ ìœ„ì•„ë˜ ì›€ì§ì„
                gsap.to(panel.position, {
                    y: panel.position.y + 1.2,
                    duration: 4 + i * 0.2,
                    repeat: -1,
                    yoyo: true,
                    ease: "sine.inOut"
                });
            }
            
            // ì—ë„ˆì§€ í•„ë“œ
            const fieldGeometry = new THREE.RingGeometry(3, 3.5, 24);
            const fieldMaterial = new THREE.MeshBasicMaterial({ 
                color: goblinData.color,
                transparent: true,
                opacity: 0.15,
                side: THREE.DoubleSide
            });
            const field = new THREE.Mesh(fieldGeometry, fieldMaterial);
            field.rotation.x = -Math.PI / 2;
            field.position.y = 0.1;
            goblinGroup.add(field);
            
            // ì´ë¦„í‘œ ì¶”ê°€
            const nameTag = createFutureGoblinNameTag(goblinData.name, goblinData.specialty);
            nameTag.position.set(0, 6.5, 0);
            goblinGroup.add(nameTag);
            
            // ìœ„ì¹˜ ì„¤ì • (ìœ¡ê°í˜• ë°°ì¹˜)
            const angle = (index / futureGoblins.length) * Math.PI * 2;
            const radius = 25;
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;
            goblinGroup.position.set(x, 0, z);
            
            goblinGroup.lookAt(0, 1, 0);
            
            goblinGroup.userData = {
                goblinData: goblinData,
                index: index,
                isFutureGoblin: true
            };
            
            // ì‚¬ì´ë²„ ì• ë‹ˆë©”ì´ì…˜ë“¤
            
            // ì—ë„ˆì§€ ì½”ì–´ í„ìŠ¤
            gsap.to(core.scale, {
                x: 1.8, y: 1.8, z: 1.8,
                duration: 2 + index * 0.2,
                repeat: -1,
                yoyo: true,
                ease: "sine.inOut"
            });
            
            // ë°”ì´ì € ê¹œë¹¡ì„
            gsap.to(visor.material, {
                opacity: 0.3,
                duration: 3 + index * 0.3,
                repeat: -1,
                yoyo: true,
                ease: "sine.inOut"
            });
            
            // ì—ë„ˆì§€ í•„ë“œ íšŒì „
            gsap.to(field.rotation, {
                z: Math.PI * 2,
                duration: 8 + index * 0.5,
                repeat: -1,
                ease: "none"
            });
            
            // ë¶€ë“œëŸ¬ìš´ ë¶€ìœ  ì• ë‹ˆë©”ì´ì…˜
            gsap.to(goblinGroup.position, {
                y: Math.sin(index * 1.2) * 0.6,
                duration: 6 + index * 0.3,
                repeat: -1,
                yoyo: true,
                ease: "sine.inOut"
            });
            
            return goblinGroup;
        }
        
        // ğŸ¤– ë¯¸ë˜ ë„ê¹¨ë¹„ í´ë¦­ ì²˜ë¦¬
        function onFutureCityCanvasClick(event) {
            if (!camera || !scene) return;
            
            const rect = renderer.domElement.getBoundingClientRect();
            const mouse = new THREE.Vector2();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            
            const intersects = raycaster.intersectObjects(scene.children, true);
            
            if (intersects.length > 0) {
                let clickedObject = intersects[0].object;
                
                while (clickedObject && !clickedObject.userData.isFutureGoblin) {
                    clickedObject = clickedObject.parent;
                }
                
                if (clickedObject && clickedObject.userData.isFutureGoblin) {
                    const goblinData = clickedObject.userData.goblinData;
                    selectFutureGoblin(goblinData);
                    
                    gsap.to(clickedObject.scale, {
                        x: 1.2, y: 1.2, z: 1.2,
                        duration: 0.2,
                        yoyo: true,
                        repeat: 1,
                        ease: "power2.out"
                    });
                }
            }
        }
        
        // ğŸ¤– ë¯¸ë˜ ë„ê¹¨ë¹„ ì¹´ë“œ ìƒì„±
        function createFutureGoblinCards() {
            const gridElement = document.getElementById('futureGoblinGrid');
            
            futureGoblins.forEach((goblin, index) => {
                const card = document.createElement('div');
                card.className = 'future-goblin-card';
                card.onclick = () => selectFutureGoblin(goblin);
                
                card.innerHTML = `
                    <div class="goblin-name">${goblin.name}</div>
                    <div class="goblin-specialty">${goblin.specialty}</div>
                    <div style="font-size: 12px; color: #7dd3fc;">${goblin.description}</div>
                `;
                
                gridElement.appendChild(card);
            });
        }
        
        // ğŸ¤– ë¯¸ë˜ ë„ê¹¨ë¹„ ì„ íƒ
        function selectFutureGoblin(goblin) {
            updateStatus(`ğŸ¤– ${goblin.name}ê³¼ ë¯¸ë˜ ê¸°ìˆ  í˜‘ì—…ì„ ì‹œì‘í•©ë‹ˆë‹¤!`);
            console.log('ì„ íƒëœ ë¯¸ë˜ ë„ê¹¨ë¹„:', goblin);
            
            // ğŸ™ï¸ ì±„íŒ… ì‹œìŠ¤í…œ ì—´ê¸°
            openChat(goblin);
            
            setTimeout(() => {
                updateStatus(`ğŸ”® ${goblin.name}: "${goblin.description}"`);
            }, 1500);
        }

        // ğŸ™ï¸ ì±„íŒ… ì‹œìŠ¤í…œ ì—´ê¸°
        function openChat(goblin) {
            currentChatGoblin = goblin;
            
            const chatContainer = document.getElementById('chatContainer');
            const chatTitle = document.getElementById('chatTitle');
            const chatMessages = document.getElementById('chatMessages');
            
            chatTitle.textContent = `ğŸ™ï¸ ${goblin.name}ê³¼ì˜ ë¯¸ë˜ ëŒ€í™”`;
            chatMessages.innerHTML = `
                <div class="message goblin-message">
                    <div class="avatar">ğŸ¤–</div>
                    <div class="text">${goblin.name}: ì•ˆë…•í•˜ì„¸ìš”! ë¯¸ë˜ ë„ì‹œì— ì˜¤ì‹  ê²ƒì„ í™˜ì˜í•©ë‹ˆë‹¤. ì–´ë–¤ ë¯¸ë˜ ê¸°ìˆ ì— ëŒ€í•´ ì´ì•¼ê¸°í•˜ê³  ì‹¶ìœ¼ì‹ ê°€ìš”? ğŸš€âœ¨</div>
                </div>
            `;
            
            chatContainer.style.display = 'flex';
            document.getElementById('chatInput').focus();
        }

        // ğŸ™ï¸ ì±„íŒ… ì‹œìŠ¤í…œ ë‹«ê¸°
        function closeChat() {
            document.getElementById('chatContainer').style.display = 'none';
            currentChatGoblin = null;
        }

        // ğŸ™ï¸ ì±„íŒ… ì…ë ¥ ì²˜ë¦¬
        function handleChatKeyPress(event) {
            if (event.key === 'Enter') {
                sendChatMessage();
            }
        }

        // ğŸ™ï¸ ì±„íŒ… ë©”ì‹œì§€ ì „ì†¡
        function sendChatMessage() {
            const chatInput = document.getElementById('chatInput');
            const message = chatInput.value.trim();
            
            if (message && currentChatGoblin) {
                const chatMessages = document.getElementById('chatMessages');
                
                // ì‚¬ìš©ì ë©”ì‹œì§€ ì¶”ê°€
                chatMessages.innerHTML += `
                    <div class="message user-message">
                        <div class="text">${message}</div>
                        <div class="avatar">ğŸ‘¤</div>
                    </div>
                `;
                
                // ë„ê¹¨ë¹„ ì‘ë‹µ ìƒì„±
                const response = generateFutureGoblinResponse(currentChatGoblin, message);
                
                setTimeout(() => {
                    chatMessages.innerHTML += `
                        <div class="message goblin-message">
                            <div class="avatar">ğŸ¤–</div>
                            <div class="text">${currentChatGoblin.name}: ${response}</div>
                        </div>
                    `;
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                }, 1000);
                
                chatInput.value = '';
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }
        }

        // ğŸ™ï¸ ë¯¸ë˜ ë„ê¹¨ë¹„ AI ì‘ë‹µ ìƒì„±
        function generateFutureGoblinResponse(goblin, userMessage) {
            const message = userMessage.toLowerCase();
            
            // ë¯¸ë˜ ê¸°ìˆ  ë¶„ì•¼ë³„ ì „ë¬¸ ì‘ë‹µ
            if (goblin.name === 'ì–‘ìì»´í“¨í„°') {
                if (message.includes('ì–‘ì') || message.includes('ì»´í“¨í„°') || message.includes('íë¹—')) {
                    return "ì–‘ìì»´í“¨í„°ëŠ” íë¹—ì˜ ì¤‘ì²©ê³¼ ì–½í˜ì„ ì´ìš©í•´ ê¸°ì¡´ ì»´í“¨í„°ë¡œëŠ” ë¶ˆê°€ëŠ¥í•œ ë³µì¡í•œ ê³„ì‚°ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤! ì•”í˜¸í•´ë…, ì‹ ì•½ê°œë°œ, ìµœì í™” ë¬¸ì œì— í˜ëª…ì„ ì¼ìœ¼í‚¬ ê±°ì˜ˆìš”. âš›ï¸ğŸ’»";
                } else if (message.includes('ìŠˆí¼í¬ì§€ì…˜') || message.includes('ì–½í˜')) {
                    return "ì–‘ì ì¤‘ì²©ì€ íë¹—ì´ 0ê³¼ 1ì„ ë™ì‹œì— ì¡´ì¬í•  ìˆ˜ ìˆê²Œ í•˜ê³ , ì–‘ì ì–½í˜ì€ ë¨¼ ê±°ë¦¬ì˜ íë¹—ë“¤ì´ ìˆœê°„ì ìœ¼ë¡œ ì •ë³´ë¥¼ ê³µìœ í•˜ê²Œ í•©ë‹ˆë‹¤. ì§„ì •í•œ ë§ˆë²• ê°™ì€ ë¬¼ë¦¬í•™ì´ì£ ! ğŸŒŸğŸ”¬";
                } else if (message.includes('ë¯¸ë˜') || message.includes('ì‘ìš©')) {
                    return "2030ë…„ëŒ€ì—ëŠ” ì–‘ìì»´í“¨í„°ê°€ AI í›ˆë ¨, ë‚ ì”¨ ì˜ˆì¸¡, ê¸ˆìœµ ëª¨ë¸ë§ì„ í˜ì‹ í•  ê²ƒì…ë‹ˆë‹¤. êµ¬ê¸€ê³¼ IBMì´ ì´ë¯¸ í° ë°œì „ì„ ì´ë£¨ê³  ìˆì–´ìš”! ğŸš€ğŸ“ˆ";
                }
            } else if (goblin.name === 'í™€ë¡œê·¸ë¨ë°•ì‚¬') {
                if (message.includes('í™€ë¡œê·¸ë¨') || message.includes('ar') || message.includes('ì¦ê°•í˜„ì‹¤')) {
                    return "í™€ë¡œê·¸ë¨ ê¸°ìˆ ì€ 3ì°¨ì› ì´ë¯¸ì§€ë¥¼ ê³µê°„ì— íˆ¬ì˜í•˜ëŠ” ë¯¸ë˜ì˜ ë””ìŠ¤í”Œë ˆì´ì…ë‹ˆë‹¤! AR/VRê³¼ ê²°í•©í•˜ì—¬ ì™„ì „íˆ ìƒˆë¡œìš´ ì†Œí†µ ë°©ì‹ì„ ë§Œë“¤ì–´ë‚¼ ê±°ì˜ˆìš”. ğŸ‘»âœ¨";
                } else if (message.includes('êµìœ¡') || message.includes('ì˜ë£Œ')) {
                    return "í™€ë¡œê·¸ë¨ì€ êµìœ¡ê³¼ ì˜ë£Œ ë¶„ì•¼ë¥¼ í˜ì‹ í•©ë‹ˆë‹¤. 3D í•´ë¶€í•™ ìˆ˜ì—…, ì›ê²© ìˆ˜ìˆ  ì§€ì›, ì—­ì‚¬ ì¸ë¬¼ê³¼ì˜ ëŒ€í™”ê¹Œì§€ ê°€ëŠ¥í•´ì§ˆ ê±°ì˜ˆìš”! ğŸ“âš•ï¸";
                } else if (message.includes('ì˜í™”') || message.includes('ì—”í„°í…Œì¸ë¨¼íŠ¸')) {
                    return "ìŠ¤íƒ€ì›Œì¦ˆì˜ ë ˆì´ì•„ ê³µì£¼ í™€ë¡œê·¸ë¨ì´ í˜„ì‹¤ì´ ë©ë‹ˆë‹¤! ì½˜ì„œíŠ¸, ì˜í™”, ê²Œì„ì—ì„œ ì™„ì „íˆ ìƒˆë¡œìš´ ê²½í—˜ì„ ì œê³µí•  ê±°ì˜ˆìš”. ğŸ¬ğŸµ";
                }
            } else if (goblin.name === 'ìš°ì£¼íƒí—˜ê°€') {
                if (message.includes('ìš°ì£¼') || message.includes('í™”ì„±') || message.includes('ë‹¬')) {
                    return "ì¸ë¥˜ì˜ ë¯¸ë˜ëŠ” ìš°ì£¼ì— ìˆìŠµë‹ˆë‹¤! ë‹¬ ê¸°ì§€, í™”ì„± ì´ì£¼, ì†Œí–‰ì„± ì±„êµ´ê¹Œì§€ ìš°ì£¼ëŠ” ë¬´í•œí•œ ê°€ëŠ¥ì„±ì˜ ê³µê°„ì´ì—ìš”. SpaceXì™€ NASAê°€ ì´ë¯¸ í° ì§„ì „ì„ ë³´ì´ê³  ìˆì–´ìš”! ğŸš€ğŸŒŒ";
                } else if (message.includes('ìš°ì£¼ì—¬í–‰') || message.includes('ìš°ì£¼ê´€ê´‘')) {
                    return "2030ë…„ëŒ€ì—ëŠ” ìš°ì£¼ ê´€ê´‘ì´ ì¼ë°˜í™”ë  ê±°ì˜ˆìš”! ë¸”ë£¨ ì˜¤ë¦¬ì§„, ë²„ì§„ ê°¤ëŸ­í‹±ì´ ìš°ì£¼ í˜¸í…”ì„ ê±´ì„¤í•˜ê³ , ì¼ë°˜ì¸ë„ ìš°ì£¼ë¥¼ ê²½í—˜í•  ìˆ˜ ìˆê²Œ ë  ê²ƒì…ë‹ˆë‹¤. ğŸ¨ğŸŒŸ";
                } else if (message.includes('ì™¸ê³„ìƒëª…') || message.includes('ì™¸ê³„ì¸')) {
                    return "ì™¸ê³„ ìƒëª…ì²´ ë°œê²¬ì€ ì‹œê°„ ë¬¸ì œì…ë‹ˆë‹¤! ì¼€í”ŒëŸ¬ ë§ì›ê²½ê³¼ ì œì„ìŠ¤ ì›¹ ë§ì›ê²½ì´ ì§€êµ¬ì™€ ë¹„ìŠ·í•œ í–‰ì„±ë“¤ì„ ì°¾ê³  ìˆì–´ìš”. ê³§ ë†€ë¼ìš´ ì†Œì‹ì´ ìˆì„ ê±°ì˜ˆìš”! ğŸ‘½ğŸ”­";
                }
            } else if (goblin.name === 'ë‚˜ë…¸ë¡œë´‡') {
                if (message.includes('ë‚˜ë…¸') || message.includes('ë¡œë´‡') || message.includes('ì˜ë£Œ')) {
                    return "ë‚˜ë…¸ë¡œë´‡ì€ í˜ˆê´€ ì†ì„ ëŒì•„ë‹¤ë‹ˆë©° ì•”ì„¸í¬ë¥¼ ì°¾ì•„ ì œê±°í•˜ê³ , ì•½ë¬¼ì„ ì •í™•í•œ ìœ„ì¹˜ì— ì „ë‹¬í•©ë‹ˆë‹¤! ì˜ë£Œì˜ ë¯¸ë˜ë¥¼ ë°”ê¿€ í˜ì‹ ì  ê¸°ìˆ ì´ì—ìš”. ğŸ¤–ğŸ’Š";
                } else if (message.includes('ì¹˜ë£Œ') || message.includes('ìˆ˜ìˆ ')) {
                    return "ë¯¸ì„¸ ìˆ˜ìˆ , í˜ˆì „ ì œê±°, ë©´ì—­ ì‹œìŠ¤í…œ ê°•í™”ê¹Œì§€ ë‚˜ë…¸ë¡œë´‡ì´ ë‹´ë‹¹í•  ê±°ì˜ˆìš”. ëª¸ì† ì˜ì‚¬ê°€ 24ì‹œê°„ ê±´ê°•ì„ ì§€ì¼œì£¼ëŠ” ì‹œëŒ€ê°€ ì˜¬ ê²ƒì…ë‹ˆë‹¤! âš•ï¸ğŸ”¬";
                } else if (message.includes('ë¶€ì‘ìš©') || message.includes('ì•ˆì „')) {
                    return "ë‚˜ë…¸ë¡œë´‡ì€ ìƒì²´ ì¹œí™”ì  ì†Œì¬ë¡œ ë§Œë“¤ì–´ì ¸ ë¶€ì‘ìš©ì„ ìµœì†Œí™”í•©ë‹ˆë‹¤. ì„ë¬´ ì™„ë£Œ í›„ ìì—° ë¶„í•´ë˜ì–´ ëª¸ì— í•´ë¥¼ ë¼ì¹˜ì§€ ì•Šì•„ìš”! ğŸ›¡ï¸âœ¨";
                }
            } else if (goblin.name === 'ë°”ì´ì˜¤í•´ì»¤') {
                if (message.includes('ë°”ì´ì˜¤') || message.includes('ìœ ì „ì') || message.includes('í¬ë¦¬ìŠ¤í¼')) {
                    return "ìœ ì „ì í¸ì§‘ ê¸°ìˆ ë¡œ ì§ˆë³‘ì„ ê·¼ë³¸ì ìœ¼ë¡œ ì¹˜ë£Œí•˜ê³ , ì¸ê°„ì˜ ëŠ¥ë ¥ì„ í–¥ìƒì‹œí‚¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤! CRISPR-Cas9ëŠ” ìƒëª…ê³¼í•™ì˜ í˜ëª…ì´ì—ìš”. ğŸ§¬âš¡";
                } else if (message.includes('ë…¸í™”') || message.includes('ìˆ˜ëª…')) {
                    return "í…”ë¡œë¯¸ì–´ ì—°ì¥, ì„¸í¬ ì¬ìƒ ê¸°ìˆ ë¡œ ì¸ê°„ì˜ ìˆ˜ëª…ì„ í¬ê²Œ ëŠ˜ë¦´ ìˆ˜ ìˆì–´ìš”. 150ì„¸ê¹Œì§€ ê±´ê°•í•˜ê²Œ ì‚¬ëŠ” ì‹œëŒ€ê°€ ì˜¬ì§€ë„ ëª°ë¼ìš”! ğŸ‘´â¡ï¸ğŸ‘¦";
                } else if (message.includes('ìœ¤ë¦¬') || message.includes('ë¬¸ì œ')) {
                    return "ìœ ì „ì í¸ì§‘ì€ ê°•ë ¥í•œ ê¸°ìˆ ì´ì§€ë§Œ ìœ¤ë¦¬ì  ê³ ë ¤ê°€ ì¤‘ìš”í•©ë‹ˆë‹¤. ì¹˜ë£Œ ëª©ì ì€ ì¢‹ì§€ë§Œ, ì¸ê°„ ê°œì¡°ëŠ” ì‹ ì¤‘í•´ì•¼ í•´ìš”. ê· í˜•ì´ í•„ìš”í•œ ë¶„ì•¼ì£ ! âš–ï¸ğŸ¤”";
                }
            } else if (goblin.name === 'ë©”íƒ€ë²„ìŠ¤ê±´ì¶•ê°€') {
                if (message.includes('ë©”íƒ€ë²„ìŠ¤') || message.includes('ê°€ìƒì„¸ê³„') || message.includes('vr')) {
                    return "ë©”íƒ€ë²„ìŠ¤ëŠ” í˜„ì‹¤ê³¼ ê°€ìƒì´ ìœµí•©ëœ ìƒˆë¡œìš´ ì„¸ê³„ì…ë‹ˆë‹¤! ê°€ìƒ ë¶€ë™ì‚°, ë””ì§€í„¸ ì•„ë°”íƒ€, NFT ì˜ˆìˆ í’ˆìœ¼ë¡œ ì™„ì „íˆ ìƒˆë¡œìš´ ê²½ì œê°€ ë§Œë“¤ì–´ì§€ê³  ìˆì–´ìš”. ğŸ—ï¸ğŸŒ";
                } else if (message.includes('íšŒì˜') || message.includes('ì—…ë¬´')) {
                    return "ì›ê²© ì—…ë¬´ì˜ ë¯¸ë˜ëŠ” ë©”íƒ€ë²„ìŠ¤ì— ìˆì–´ìš”! ê°€ìƒ ì˜¤í”¼ìŠ¤ì—ì„œ ì•„ë°”íƒ€ë¡œ íšŒì˜í•˜ê³ , 3D í”„ë ˆì  í…Œì´ì…˜ìœ¼ë¡œ í˜‘ì—…í•˜ëŠ” ì‹œëŒ€ê°€ ì™”ìŠµë‹ˆë‹¤. ğŸ‘¥ğŸ’¼";
                } else if (message.includes('êµìœ¡') || message.includes('í•™ìŠµ')) {
                    return "ë©”íƒ€ë²„ìŠ¤ êµìœ¡ì€ í˜ì‹ ì ì…ë‹ˆë‹¤! ë¡œë§ˆ ì½œë¡œì„¸ì›€ì—ì„œ ì—­ì‚¬ë¥¼ ë°°ìš°ê³ , ë¶„ì êµ¬ì¡° ì•ˆì—ì„œ í™”í•™ì„ ê³µë¶€í•  ìˆ˜ ìˆì–´ìš”. ì²´í—˜í˜• í•™ìŠµì˜ ìƒˆ ì‹œëŒ€ì£ ! ğŸ“ğŸ›ï¸";
                }
            }
            
            // ì¼ë°˜ì ì¸ ë¯¸ë˜ ê¸°ìˆ  ì‘ë‹µ
            const generalResponses = [
                `${goblin.name}ì´ ${goblin.description.slice(0, 50)}... ë¯¸ë˜ ê¸°ìˆ ì— ëŒ€í•´ ë” ê¶ê¸ˆí•œ ê²ƒì´ ìˆìœ¼ì‹ ê°€ìš”? ğŸ¤–âœ¨`,
                "ë¯¸ë˜ëŠ” ìƒìƒí•˜ëŠ” ëª¨ë“  ê²ƒì´ í˜„ì‹¤ì´ ë˜ëŠ” ì‹œëŒ€ì…ë‹ˆë‹¤! ì–´ë–¤ ê¸°ìˆ ì´ ê°€ì¥ ê¸°ëŒ€ë˜ì‹œë‚˜ìš”? ğŸš€ğŸŒŸ",
                "ê³¼í•™ ê¸°ìˆ ì˜ ë°œì „ ì†ë„ëŠ” ì ì  ë¹¨ë¼ì§€ê³  ìˆì–´ìš”. í•¨ê»˜ ë¯¸ë˜ë¥¼ ë§Œë“¤ì–´ê°€ë´…ì‹œë‹¤! ğŸ’¡ğŸ”¬",
                "SF ì˜í™” ì† ê¸°ìˆ ë“¤ì´ í•˜ë‚˜ì”© í˜„ì‹¤ì´ ë˜ê³  ìˆì–´ìš”. 10ë…„ í›„ëŠ” ì–´ë–¨ê¹Œìš”? ğŸ¬ğŸ”®",
                "í˜ì‹ ì ì¸ ê¸°ìˆ ì€ ì¸ë¥˜ì˜ ì‚¶ì„ ë” í’ìš”ë¡­ê²Œ ë§Œë“­ë‹ˆë‹¤. ë¯¸ë˜ê°€ ì •ë§ ê¸°ëŒ€ë˜ë„¤ìš”! ğŸŒˆğŸ’«"
            ];
            
            return generalResponses[Math.floor(Math.random() * generalResponses.length)];
        }
        
        // ğŸ™ï¸ ë¯¸ë˜ ë„ì‹œ í™˜ê²½ ìƒì„±
        function createFutureCityEnvironment() {
            // ğŸ¢ ë¯¸ë˜ ê³ ì¸µ ë¹Œë”©ë“¤
            for (let i = 0; i < 25; i++) {
                createFutureSkyscraper();
            }
            
            // ğŸš ë– ë‹¤ë‹ˆëŠ” ë“œë¡ ë“¤
            for (let i = 0; i < 20; i++) {
                createFlyingDrone();
            }
            
            // âš¡ ì—ë„ˆì§€ íƒ€ì›Œë“¤
            for (let i = 0; i < 8; i++) {
                createEnergyTower();
            }
            
            // ğŸŒƒ ì‚¬ì´ë²„ ì¡°ëª…
            createCyberLighting();
        }
        
        // ğŸ¢ ë¯¸ë˜ ê³ ì¸µ ë¹Œë”© ìƒì„±
        function createFutureSkyscraper() {
            const buildingGroup = new THREE.Group();
            
            const height = 15 + Math.random() * 25;
            const width = 3 + Math.random() * 2;
            
            // ê±´ë¬¼ ë³¸ì²´
            const buildingGeometry = new THREE.BoxGeometry(width, height, width);
            const buildingMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x1a252f,
                emissive: 0x00ff88,
                emissiveIntensity: 0.1,
                shininess: 100
            });
            const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
            building.position.y = height / 2;
            buildingGroup.add(building);
            
            // í™€ë¡œê·¸ë¨ ì‚¬ì¸
            const signGeometry = new THREE.PlaneGeometry(width * 0.8, 2);
            const signMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00ffaa,
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide
            });
            const sign = new THREE.Mesh(signGeometry, signMaterial);
            sign.position.set(0, height - 2, width / 2 + 0.1);
            buildingGroup.add(sign);
            
            // ê±´ë¬¼ ì°½ë“¤ (ë„¤ì˜¨ ë¶ˆë¹›)
            for (let floor = 0; floor < Math.floor(height / 3); floor++) {
                for (let window = 0; window < 3; window++) {
                    if (Math.random() > 0.3) { // 70% í™•ë¥ ë¡œ ë¶ˆ ì¼œì§
                        const windowGeometry = new THREE.PlaneGeometry(0.3, 0.3);
                        const windowMaterial = new THREE.MeshBasicMaterial({ 
                            color: Math.random() > 0.5 ? 0x00ff88 : 0x00ffaa,
                            emissive: Math.random() > 0.5 ? 0x00ff88 : 0x00ffaa,
                            emissiveIntensity: 0.8
                        });
                        const windowMesh = new THREE.Mesh(windowGeometry, windowMaterial);
                        windowMesh.position.set(
                            (window - 1) * 0.8,
                            2 + floor * 3,
                            width / 2 + 0.05
                        );
                        buildingGroup.add(windowMesh);
                    }
                }
            }
            
            const x = (Math.random() - 0.5) * 120;
            const z = (Math.random() - 0.5) * 120;
            buildingGroup.position.set(x, 0, z);
            
            // í™€ë¡œê·¸ë¨ ì‚¬ì¸ ê¹œë¹¡ì„
            gsap.to(sign.material, {
                opacity: 0.3,
                duration: 2 + Math.random() * 2,
                repeat: -1,
                yoyo: true,
                ease: "sine.inOut"
            });
            
            scene.add(buildingGroup);
        }
        
        // ğŸš ë– ë‹¤ë‹ˆëŠ” ë“œë¡  ìƒì„±
        function createFlyingDrone() {
            const droneGroup = new THREE.Group();
            
            // ë“œë¡  ë³¸ì²´
            const bodyGeometry = new THREE.SphereGeometry(0.3);
            const bodyMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x2c3e50,
                emissive: 0x00ff88,
                emissiveIntensity: 0.3
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            droneGroup.add(body);
            
            // ë“œë¡  í”„ë¡œí ëŸ¬ë“¤
            for (let i = 0; i < 4; i++) {
                const propGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.8);
                const propMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x00ffaa,
                    transparent: true,
                    opacity: 0.6
                });
                const prop = new THREE.Mesh(propGeometry, propMaterial);
                
                const angle = (i / 4) * Math.PI * 2;
                prop.position.set(
                    Math.cos(angle) * 0.6,
                    0,
                    Math.sin(angle) * 0.6
                );
                prop.rotation.z = Math.PI / 2;
                droneGroup.add(prop);
                
                // í”„ë¡œí ëŸ¬ íšŒì „
                gsap.to(prop.rotation, {
                    y: Math.PI * 2,
                    duration: 0.1,
                    repeat: -1,
                    ease: "none"
                });
            }
            
            // LED ë¼ì´íŠ¸
            const lightGeometry = new THREE.SphereGeometry(0.1);
            const lightMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00ff88,
                emissive: 0x00ff88,
                emissiveIntensity: 1
            });
            const light = new THREE.Mesh(lightGeometry, lightMaterial);
            light.position.y = -0.3;
            droneGroup.add(light);
            
            const x = (Math.random() - 0.5) * 100;
            const y = 10 + Math.random() * 20;
            const z = (Math.random() - 0.5) * 100;
            droneGroup.position.set(x, y, z);
            
            // ë“œë¡  ìˆœì°° ì›€ì§ì„
            gsap.to(droneGroup.position, {
                x: x + (Math.random() - 0.5) * 30,
                y: y + (Math.random() - 0.5) * 10,
                z: z + (Math.random() - 0.5) * 30,
                duration: 8 + Math.random() * 4,
                repeat: -1,
                yoyo: true,
                ease: "sine.inOut"
            });
            
            // LED ê¹œë¹¡ì„
            gsap.to(light.material, {
                emissiveIntensity: 0.3,
                duration: 1,
                repeat: -1,
                yoyo: true,
                ease: "sine.inOut"
            });
            
            scene.add(droneGroup);
        }
        
        // âš¡ ì—ë„ˆì§€ íƒ€ì›Œ ìƒì„±
        function createEnergyTower() {
            const towerGroup = new THREE.Group();
            
            // íƒ€ì›Œ ê¸°ë‘¥
            const poleGeometry = new THREE.CylinderGeometry(0.5, 0.8, 20);
            const poleMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x2c3e50,
                emissive: 0x00ff88,
                emissiveIntensity: 0.2
            });
            const pole = new THREE.Mesh(poleGeometry, poleMaterial);
            pole.position.y = 10;
            towerGroup.add(pole);
            
            // ì—ë„ˆì§€ êµ¬ì²´
            const sphereGeometry = new THREE.SphereGeometry(1.5);
            const sphereMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00ff88,
                emissive: 0x00ff88,
                emissiveIntensity: 0.8,
                transparent: true,
                opacity: 0.7
            });
            const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            sphere.position.y = 22;
            towerGroup.add(sphere);
            
            // ì—ë„ˆì§€ ë§ë“¤
            for (let i = 0; i < 3; i++) {
                const ringGeometry = new THREE.RingGeometry(2 + i * 0.5, 2.5 + i * 0.5, 16);
                const ringMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x00ffaa,
                    transparent: true,
                    opacity: 0.6 - i * 0.1,
                    side: THREE.DoubleSide
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.position.y = 22;
                ring.rotation.x = Math.random() * Math.PI;
                towerGroup.add(ring);
                
                // ë§ íšŒì „
                gsap.to(ring.rotation, {
                    z: Math.PI * 2,
                    duration: 4 + i,
                    repeat: -1,
                    ease: "none"
                });
            }
            
            const angle = (Math.PI * 2 / 8) * (scene.children.filter(child => 
                child.userData && child.userData.isEnergyTower).length);
            const radius = 45;
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;
            towerGroup.position.set(x, 0, z);
            
            towerGroup.userData.isEnergyTower = true;
            
            // ì—ë„ˆì§€ êµ¬ì²´ í„ìŠ¤
            gsap.to(sphere.scale, {
                x: 1.3, y: 1.3, z: 1.3,
                duration: 3,
                repeat: -1,
                yoyo: true,
                ease: "sine.inOut"
            });
            
            scene.add(towerGroup);
        }
        
        // ğŸŒƒ ì‚¬ì´ë²„ ì¡°ëª…
        function createCyberLighting() {
            const ambientLight = new THREE.AmbientLight(0x1a252f, 0.2);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0x00ff88, 0.6);
            directionalLight.position.set(30, 40, 30);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // ë„¤ì˜¨ ì¡°ëª…ë“¤
            for (let i = 0; i < 8; i++) {
                const neonLight = new THREE.PointLight(0x00ff88, 0.8, 30);
                neonLight.position.set(
                    Math.cos(i) * 40,
                    15,
                    Math.sin(i) * 40
                );
                scene.add(neonLight);
                
                // ë„¤ì˜¨ ê¹œë¹¡ì„
                gsap.to(neonLight, {
                    intensity: 0.3,
                    duration: 2 + i * 0.2,
                    repeat: -1,
                    yoyo: true,
                    ease: "sine.inOut"
                });
            }
        }
        
        // ğŸ™ï¸ ë¯¸ë˜ ë„ì‹œ ì´ˆê¸°í™”
        function initFutureCity() {
            console.log('ğŸ™ï¸ ë¯¸ë˜ ë„ì‹œ ì´ˆê¸°í™” ì‹œì‘...');
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0f1419);
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 25, 35);
            
            const canvas = document.getElementById('future-city-canvas');
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            
            // ğŸ™ï¸ ë¯¸ë˜ ë„ì‹œ í™˜ê²½ ìƒì„±
            createFutureCityEnvironment();
            
            // ğŸ¤– 3D ë¯¸ë˜ ë„ê¹¨ë¹„ë“¤ ìƒì„±
            createFuture3DGoblins();
            
            // ğŸ¤– ë¯¸ë˜ ë„ê¹¨ë¹„ ì¹´ë“œ ìƒì„±
            createFutureGoblinCards();
            
            // ğŸ–±ï¸ ìº”ë²„ìŠ¤ í´ë¦­ ì´ë²¤íŠ¸ ì¶”ê°€
            canvas.addEventListener('click', onFutureCityCanvasClick);
            
            isSystemReady = true;
            updateStatus('ğŸ™ï¸ ë¯¸ë˜ ë„ì‹œê°€ ì™„ì„±ë˜ì—ˆìŠµë‹ˆë‹¤! ì‚¬ì´ë²„ ì„¸ê³„ë¥¼ íƒí—˜í•˜ì„¸ìš”!');
            
            animate();
        }
        
        // ğŸ¬ ì• ë‹ˆë©”ì´ì…˜ ë£¨í”„
        function animate() {
            requestAnimationFrame(animate);
            
            if (controls) {
                controls.update();
            }
            
            if (avatar && controls) {
                controls.target.copy(avatar.position);
                controls.target.y += 1;
            }
            
            // ğŸ·ï¸ ëª¨ë“  ì´ë¦„í‘œë“¤ì´ ì¹´ë©”ë¼ë¥¼ ë°”ë¼ë³´ë„ë¡ ì—…ë°ì´íŠ¸
            scene.traverse((object) => {
                if (object.userData && object.userData.isNameTag && camera) {
                    object.lookAt(camera.position);
                }
            });
            
            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
        }
        
        // ğŸ“± ìœˆë„ìš° ë¦¬ì‚¬ì´ì¦ˆ ì²˜ë¦¬
        window.addEventListener('resize', () => {
            if (camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        });
        
        // ğŸš€ ë¯¸ë˜ ë„ì‹œ ì‹œì‘
        window.addEventListener('load', () => {
            initFutureCity();
        });
    </script>
</body>
</html>
