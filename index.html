<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🌌 도깨비 메타버스 3D 월드 - 차세대 AI 대화 시스템</title>
    
    <!-- Three.js 및 로더들 (ES6 모듈 방식 - 기존 작동 방식 적용) -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    
    <!-- GSAP 애니메이션 라이브러리 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #000;
            overflow: hidden;
            height: 100vh;
            color: white;
        }
        
        /* 🌌 메인 컨테이너 */
        .main-container {
            display: flex;
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        /* 🎮 3D 메타버스 캔버스 */
        #metaverse-canvas {
            flex: 1;
            cursor: grab;
            background: linear-gradient(180deg, #000428 0%, #004e92 100%);
        }
        
        #metaverse-canvas:active {
            cursor: grabbing;
        }
        
        /* 🏰 왼쪽 도깨비 관리 패널 */
        .goblin-panel {
            width: 380px;
            background: linear-gradient(135deg, rgba(15, 15, 35, 0.95), rgba(30, 30, 60, 0.9));
            backdrop-filter: blur(20px);
            border-right: 3px solid #4ecdc4;
            padding: 20px;
            overflow-y: auto;
            z-index: 1000;
            box-shadow: 5px 0 30px rgba(78, 205, 196, 0.3);
        }
        
        .panel-title {
            text-align: center;
            font-size: 24px;
            font-weight: bold;
            background: linear-gradient(135deg, #4ecdc4, #44a08d, #96ceb4);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            margin-bottom: 25px;
            text-shadow: 0 0 30px rgba(78, 205, 196, 0.5);
        }
        
        /* 📊 시스템 상태 패널 */
        .status-panel {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(78, 205, 196, 0.3);
            border-radius: 15px;
            padding: 15px;
            margin-bottom: 20px;
        }
        
        .status-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 14px;
        }
        
        .status-value {
            color: #4ecdc4;
            font-weight: bold;
        }
        
        /* 👹 도깨비 카드 스타일 */
        .goblin-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .goblin-card {
            background: linear-gradient(135deg, rgba(139, 69, 19, 0.8), rgba(160, 82, 45, 0.6));
            border: 2px solid transparent;
            background-clip: padding-box;
            border-radius: 15px;
            padding: 15px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .goblin-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, #4ecdc4, #44a08d);
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: -1;
        }
        
        .goblin-card:hover::before {
            opacity: 0.1;
        }
        
        .goblin-card:hover {
            transform: translateY(-5px) scale(1.02);
            box-shadow: 0 15px 40px rgba(78, 205, 196, 0.4);
            border-color: #4ecdc4;
        }
        
        .goblin-avatar {
            width: 50px;
            height: 50px;
            margin: 0 auto 10px;
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            border: 2px solid #d2691e;
            box-shadow: 0 5px 15px rgba(78, 205, 196, 0.3);
        }
        
        .goblin-name {
            font-size: 14px;
            font-weight: bold;
            color: #ffd700;
            margin-bottom: 5px;
        }
        
        .goblin-role {
            font-size: 11px;
            color: #ccc;
            margin-bottom: 8px;
        }
        
        .goblin-status {
            font-size: 10px;
            padding: 3px 8px;
            background: rgba(76, 175, 80, 0.3);
            border-radius: 10px;
            color: #4caf50;
            display: inline-block;
        }
        
        /* 🎮 컨트롤 버튼들 */
        .control-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .control-btn {
            padding: 12px;
            background: linear-gradient(135deg, #4ecdc4, #44a08d);
            border: none;
            border-radius: 10px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 12px;
        }
        
        .control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(78, 205, 196, 0.4);
        }
        
        /* 🌟 우상단 시스템 정보 */
        .system-info {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(78, 205, 196, 0.3);
            border-radius: 15px;
            padding: 15px;
            z-index: 1001;
            min-width: 200px;
        }
        
        .system-info h3 {
            color: #4ecdc4;
            margin-bottom: 10px;
            font-size: 16px;
        }
        
        .info-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 12px;
        }
        
        /* 💬 채팅창 오버레이 */
        .chat-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            z-index: 10000;
            display: none;
            align-items: center;
            justify-content: center;
        }
        
        .chat-window {
            width: 90%;
            max-width: 700px;
            max-height: 85vh;
            background: linear-gradient(135deg, rgba(15, 15, 35, 0.95), rgba(30, 30, 60, 0.9));
            border: 2px solid #4ecdc4;
            border-radius: 25px;
            padding: 30px;
            backdrop-filter: blur(25px);
            box-shadow: 0 25px 60px rgba(0, 0, 0, 0.5);
            position: relative;
        }
        
        .chat-header {
            text-align: center;
            margin-bottom: 25px;
            border-bottom: 1px solid rgba(78, 205, 196, 0.3);
            padding-bottom: 20px;
        }
        
        .chat-emoji {
            font-size: 80px;
            display: block;
            margin-bottom: 15px;
            filter: drop-shadow(0 0 20px rgba(78, 205, 196, 0.5));
        }
        
        .chat-title {
            color: #4ecdc4;
            font-size: 24px;
            margin-bottom: 8px;
            font-weight: bold;
        }
        
        .chat-subtitle {
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
        }
        
        .chat-messages {
            height: 350px;
            overflow-y: auto;
            border: 1px solid rgba(78, 205, 196, 0.2);
            border-radius: 15px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            margin-bottom: 20px;
            scrollbar-width: thin;
            scrollbar-color: #4ecdc4 transparent;
        }
        
        .chat-messages::-webkit-scrollbar {
            width: 6px;
        }
        
        .chat-messages::-webkit-scrollbar-track {
            background: transparent;
        }
        
        .chat-messages::-webkit-scrollbar-thumb {
            background: #4ecdc4;
            border-radius: 3px;
        }
        
        .message {
            margin-bottom: 20px;
            animation: fadeInUp 0.3s ease;
        }
        
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .message.user {
            text-align: right;
        }
        
        .message.goblin {
            text-align: left;
        }
        
        .message-bubble {
            display: inline-block;
            padding: 15px 20px;
            border-radius: 20px;
            max-width: 85%;
            word-wrap: break-word;
            font-size: 14px;
            line-height: 1.4;
        }
        
        .message.user .message-bubble {
            background: linear-gradient(135deg, #4ecdc4, #44a08d);
            color: white;
            border-bottom-right-radius: 5px;
        }
        
        .message.goblin .message-bubble {
            background: linear-gradient(135deg, #ff6b6b, #ee5a6f);
            color: white;
            border-bottom-left-radius: 5px;
        }
        
        .chat-input-container {
            display: flex;
            gap: 15px;
            align-items: flex-end;
        }
        
        .chat-input {
            flex: 1;
            padding: 15px;
            border: 1px solid #4ecdc4;
            border-radius: 15px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            font-size: 14px;
            resize: none;
            min-height: 50px;
            max-height: 120px;
        }
        
        .chat-input:focus {
            outline: none;
            border-color: #ff6b6b;
            box-shadow: 0 0 15px rgba(78, 205, 196, 0.3);
        }
        
        .send-button {
            padding: 15px 25px;
            background: linear-gradient(135deg, #4ecdc4, #44a08d);
            color: white;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            min-width: 80px;
        }
        
        .send-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(78, 205, 196, 0.4);
        }
        
        .close-button {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: none;
            border-radius: 50%;
            width: 45px;
            height: 45px;
            cursor: pointer;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }
        
        .close-button:hover {
            background: rgba(255, 107, 107, 0.3);
            transform: rotate(90deg);
        }
        
        /* 📱 반응형 디자인 */
        @media (max-width: 768px) {
            .goblin-panel {
                width: 100%;
                height: 40vh;
                border-right: none;
                border-bottom: 3px solid #4ecdc4;
            }
            
            .main-container {
                flex-direction: column;
            }
            
            .system-info {
                position: relative;
                top: auto;
                right: auto;
                margin-bottom: 15px;
            }
            
            .goblin-grid {
                grid-template-columns: repeat(3, 1fr);
            }
            
            .chat-window {
                width: 95%;
                padding: 20px;
            }
        }
        
        /* 🎨 시각적 효과 */
        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid rgba(78, 205, 196, 0.3);
            border-radius: 50%;
            border-top-color: #4ecdc4;
            animation: spin 1s ease-in-out infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .pulse {
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
    </style>
</head>
<body>
    <div class="main-container">
        <!-- 왼쪽 도깨비 관리 패널 -->
        <div class="goblin-panel">
            <h1 class="panel-title">🌌 도깨비 메타버스 3D</h1>
            
            <!-- 시스템 상태 -->
            <div class="status-panel">
                <div class="status-item">
                    <span>🏰 활성 도깨비:</span>
                    <span class="status-value" id="activeGoblins">0/16</span>
                </div>
                <div class="status-item">
                    <span>💬 대화 수:</span>
                    <span class="status-value" id="conversationCount">0</span>
                </div>
                <div class="status-item">
                    <span>🌟 시스템 상태:</span>
                    <span class="status-value" id="systemStatus">초기화 중...</span>
                </div>
            </div>
            
            <!-- 컨트롤 버튼들 -->
            <div class="control-buttons">
                <button class="control-btn" onclick="spawnAllGoblins()">🚀 도깨비 소환</button>
                <button class="control-btn" onclick="resetWorld()">🔄 월드 리셋</button>
                <button class="control-btn" onclick="toggleWeather()">🌦️ 날씨 변경</button>
                <button class="control-btn" onclick="toggleDay()">🌅 시간 변경</button>
            </div>
            
            <!-- 도깨비 카드들 -->
            <div class="goblin-grid" id="goblinGrid">
                <!-- JavaScript로 동적 생성 -->
            </div>
        </div>
        
        <!-- 3D 메타버스 캔버스 -->
        <canvas id="metaverse-canvas"></canvas>
        
        <!-- 우상단 시스템 정보 -->
        <div class="system-info">
            <h3>🎮 시스템 정보</h3>
            <div class="info-item">
                <span>FPS:</span>
                <span id="fpsCounter">60</span>
            </div>
            <div class="info-item">
                <span>메모리:</span>
                <span id="memoryUsage">0MB</span>
            </div>
            <div class="info-item">
                <span>로드 상태:</span>
                <span id="loadStatus">준비중</span>
            </div>
        </div>
    </div>
    
    <!-- 채팅창 오버레이 -->
    <div class="chat-overlay" id="chatOverlay">
        <div class="chat-window">
            <button class="close-button" onclick="closeChat()">×</button>
            
            <div class="chat-header">
                <span class="chat-emoji" id="chatEmoji">🏥</span>
                <h3 class="chat-title" id="chatTitle">의료 전문가</h3>
                <p class="chat-subtitle" id="chatSubtitle">건강 상담 전문</p>
            </div>
            
            <div class="chat-messages" id="chatMessages">
                <!-- 메시지들이 동적으로 추가됩니다 -->
            </div>
            
            <div class="chat-input-container">
                <textarea class="chat-input" id="chatInput" 
                         placeholder="메시지를 입력하세요..." 
                         onkeypress="handleKeyPress(event)"></textarea>
                <button class="send-button" onclick="sendMessage()">
                    <span id="sendButtonText">전송</span>
                </button>
            </div>
        </div>
    </div>

    <script type="module">
        // ES6 모듈로 Three.js 및 컨트롤 임포트
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // Three.js 클래스들을 전역으로 할당 (기존 코드 호환성)
        window.THREE = THREE;
        window.OrbitControls = OrbitControls;
        
        console.log('✅ Three.js ES6 모듈 로딩 완료');

        // 🌌 글로벌 변수 및 시스템
        let scene, camera, renderer, controls;
        let goblins3D = [];
        let goblinHouses = [];
        let currentGoblin = null;
        let conversationCount = 0;
        let isSystemReady = false;
        
        // 📊 성능 모니터링
        let frameCount = 0;
        let lastTime = performance.now();
        let fps = 60;
        
        // 🎮 게임 시스템
        let weather = 'sunny';
        let timeOfDay = 'day';
        let particles = [];
        
        // 👹 16명의 도깨비 데이터 (기존 버전과 이름 통일)
        const goblinDatabase = [
            {
                id: 'medical',
                name: '의료',
                role: '건강 정보 및 의료 가이드',
                emoji: '🏥',
                color: 0x4ecdc4,
                personality: 'professional',
                position: { x: -15, z: -15 },
                specialties: ['건강', '의학', '응급처치', '예방의학']
            },
            {
                id: 'builder',
                name: '빌더',
                role: '소프트웨어 개발 및 프로그래밍',
                emoji: '�',
                color: 0x96ceb4,
                personality: 'logical',
                position: { x: -15, z: 15 },
                specialties: ['개발', '프로그래밍', '기술', 'AI']
            },
            {
                id: 'counseling',
                name: '상담',
                role: '심리 상담 및 고민 해결',
                emoji: '�',
                color: 0xff6b6b,
                personality: 'empathetic',
                position: { x: 15, z: 15 },
                specialties: ['심리', '감정', '상담', '치유']
            },
            {
                id: 'creative',
                name: '창작',
                role: '예술 창작 및 콘텐츠 제작',
                emoji: '🎨',
                color: 0xfeca57,
                personality: 'creative',
                position: { x: -25, z: 0 },
                specialties: ['창의성', '디자인', '아이디어', '예술']
            },
            {
                id: 'data-analysis',
                name: '데이터분석',
                role: '데이터 과학 및 통계 분석',
                emoji: '📊',
                color: 0x9b59b6,
                personality: 'analytical',
                position: { x: 25, z: 0 },
                specialties: ['데이터', '분석', '통계', '인사이트']
            },
            {
                id: 'seo',
                name: 'SEO',
                role: '검색엔진 최적화 및 웹마케팅',
                emoji: '�',
                color: 0x2ecc71,
                personality: 'strategic',
                position: { x: 0, z: -25 },
                specialties: ['SEO', '검색최적화', '웹마케팅', '트래픽']
            },
            {
                id: 'marketing',
                name: '마케팅',
                role: '디지털 마케팅 및 브랜딩',
                emoji: '�',
                color: 0xe74c3c,
                personality: 'energetic',
                position: { x: 10, z: -20 },
                specialties: ['마케팅', '브랜딩', '홍보', '전략']
            },
            {
                id: 'writing',
                name: '글쓰기',
                role: '문서 작성 및 콘텐츠 제작',
                emoji: '✍️',
                color: 0x2ecc71,
                personality: 'creative',
                position: { x: 0, z: 25 },
                specialties: ['글쓰기', '문서작성', '콘텐츠', '창작']
            },
            {
                id: 'sales',
                name: '컨설팅',
                role: '전략 컨설팅 및 경영 분석',
                emoji: '💼',
                color: 0x45b7d1,
                personality: 'analytical',
                position: { x: 15, z: -15 },
                specialties: ['컨설팅', '경영', '전략', '분석']
            },
            {
                id: 'hr',
                name: '인사',
                role: '인적자원 관리 및 조직 운영',
                emoji: '�',
                color: 0x34495e,
                personality: 'supportive',
                position: { x: -10, z: -20 },
                specialties: ['인사', '조직관리', '채용', '인적자원']
            },
            {
                id: 'assistant',
                name: '비서',
                role: '업무 효율화 및 일정 관리',
                emoji: '�',
                color: 0x1abc9c,
                personality: 'efficient',
                position: { x: -20, z: -10 },
                specialties: ['업무효율화', '일정관리', '자동화', '비서']
            },
            {
                id: 'startup',
                name: '창업',
                role: '창업 및 비즈니스 개발',
                emoji: '�',
                color: 0x3498db,
                personality: 'innovative',
                position: { x: 20, z: -10 },
                specialties: ['창업', '사업계획', '투자유치', '비즈니스']
            },
            {
                id: 'shopping',
                name: '쇼핑',
                role: '제품 추천 및 구매 가이드',
                emoji: '🛍️',
                color: 0x9c88ff,
                personality: 'helpful',
                position: { x: -20, z: 10 },
                specialties: ['쇼핑', '제품추천', '구매가이드', '리뷰']
            },
            {
                id: 'growth',
                name: '성장',
                role: '개인 발전 및 자기계발',
                emoji: '�',
                color: 0xff7675,
                personality: 'motivational',
                position: { x: 20, z: 10 },
                specialties: ['성장', '자기계발', '학습', '동기부여']
            },
            {
                id: 'fortune',
                name: '운세',
                role: '점술 및 미래 예측',
                emoji: '�',
                color: 0xfd79a8,
                personality: 'mystical',
                position: { x: -5, z: 5 },
                specialties: ['운세', '점술', '미래예측', '상담']
            },
            {
                id: 'village-chief',
                name: '촌장',
                role: '리더십 및 조직 관리',
                emoji: '�',
                color: 0xdda0dd,
                personality: 'wise',
                position: { x: 0, z: 0 },
                specialties: ['리더십', '조직관리', '종합상담', '지혜']
            }
        ];
        
        console.log('🌌 2단계: 16명 도깨비 데이터 시스템 완료!');
        
        // 🌌 3D 메타버스 환경 초기화
        function initMetaverse() {
            const canvas = document.getElementById('metaverse-canvas');
            
            // Scene 생성
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000428, 50, 200);
            
            // 동적 배경 (시간대별)
            updateSceneBackground();
            
            // Camera 생성 (더 다이나믹한 설정)
            camera = new THREE.PerspectiveCamera(75, canvas.offsetWidth / canvas.offsetHeight, 0.1, 1000);
            camera.position.set(0, 15, 30);
            
            // Renderer 생성 (고품질 설정)
            renderer = new THREE.WebGLRenderer({ 
                canvas: canvas, 
                antialias: true,
                alpha: true
            });
            renderer.setSize(canvas.offsetWidth, canvas.offsetHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            
            // Controls 생성 (부드러운 조작)
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 10;
            controls.maxDistance = 100;
            controls.maxPolarAngle = Math.PI / 2.1;
            controls.autoRotate = false;
            controls.autoRotateSpeed = 0.5;
            
            // 고급 조명 시스템
            setupAdvancedLighting();
            
            // 메타버스 환경 생성
            createMetaverseEnvironment();
            
            // 16개 도깨비 집들 생성
            createGoblinVillage();
            
            // 파티클 시스템 (제거됨 - 시야 방해로 인해)
            // createParticleSystem();
            
            // 이벤트 리스너
            setupEventListeners();
            
            // 애니메이션 시작
            animate();
            
            // 시스템 준비 완료
            isSystemReady = true;
            updateSystemStatus('준비 완료');
            
            console.log('🌌 3D 메타버스 환경 초기화 완료!');
        }
        
        // � 시스템 상태 업데이트
        function updateSystemStatus(status) {
            console.log(`🎮 시스템 상태: ${status}`);
            
            // UI의 시스템 상태 표시 업데이트
            const statusElements = document.querySelectorAll('.system-status');
            statusElements.forEach(element => {
                if (element) {
                    element.innerHTML = `
                        <div>🎮 시스템: ${status}</div>
                        <div>🌍 메타버스: 활성</div>
                        <div>👹 도깨비: ${goblins3D.length}/16</div>
                        <div>⚡ 상태: 정상</div>
                    `;
                }
            });
            
            // 화면에 일시적 알림 표시
            updateStatus(`시스템 상태: ${status}`);
        }
        
        // �🌅 동적 배경 시스템
        function updateSceneBackground() {
            let skyColor, fogColor;
            
            switch(timeOfDay) {
                case 'dawn':
                    skyColor = new THREE.Color(0x87CEEB);
                    fogColor = 0x87CEEB;
                    break;
                case 'day':
                    skyColor = new THREE.Color(0x87CEFA);
                    fogColor = 0x87CEFA;
                    break;
                case 'sunset':
                    skyColor = new THREE.Color(0xFF6347);
                    fogColor = 0xFF6347;
                    break;
                case 'night':
                    skyColor = new THREE.Color(0x000428);
                    fogColor = 0x000428;
                    break;
                default:
                    skyColor = new THREE.Color(0x000428);
                    fogColor = 0x000428;
            }
            
            scene.background = skyColor;
            scene.fog.color = new THREE.Color(fogColor);
        }
        
        // 💡 고급 조명 시스템
        function setupAdvancedLighting() {
            // 주변광
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);
            
            // 주 조명 (태양/달)
            const mainLight = new THREE.DirectionalLight(
                timeOfDay === 'night' ? 0x4169E1 : 0xffffff, 
                timeOfDay === 'night' ? 0.3 : 0.8
            );
            mainLight.position.set(20, 20, 10);
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.width = 2048;
            mainLight.shadow.mapSize.height = 2048;
            mainLight.shadow.camera.near = 0.1;
            mainLight.shadow.camera.far = 100;
            mainLight.shadow.camera.left = -50;
            mainLight.shadow.camera.right = 50;
            mainLight.shadow.camera.top = 50;
            mainLight.shadow.camera.bottom = -50;
            scene.add(mainLight);
            
            // 도깨비 집들을 위한 색상 조명들
            const lightColors = [0x4ecdc4, 0xff6b6b, 0x45b7d1, 0x96ceb4, 0xfeca57, 0x9b59b6];
            lightColors.forEach((color, index) => {
                const pointLight = new THREE.PointLight(color, 0.6, 30);
                const angle = (index / lightColors.length) * Math.PI * 2;
                pointLight.position.set(
                    Math.cos(angle) * 20,
                    5,
                    Math.sin(angle) * 20
                );
                scene.add(pointLight);
            });
            
            // 중앙 마법 조명
            const centralLight = new THREE.PointLight(0xffd700, 1, 40);
            centralLight.position.set(0, 10, 0);
            scene.add(centralLight);
        }
        
        // 🌍 메타버스 환경 생성
        function createMetaverseEnvironment() {
            // 지면 (더 자연스러운 텍스처)
            const groundGeometry = new THREE.PlaneGeometry(200, 200);
            const groundMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x2a4d3a,
                transparent: true,
                opacity: 0.8
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // 하늘의 별들 (밤에만 보임)
            createStars();
            
            // 마법의 크리스털들
            createMagicCrystals();
            
            // 배경 산들
            createMountains();
            
            // 중앙 포털
            createCentralPortal();
        }
        
        // ⭐ 별 생성
        function createStars() {
            const starGeometry = new THREE.BufferGeometry();
            const starCount = 2000;
            const positions = new Float32Array(starCount * 3);
            
            for (let i = 0; i < starCount * 3; i++) {
                positions[i] = (Math.random() - 0.5) * 400;
            }
            
            starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const starMaterial = new THREE.PointsMaterial({ 
                color: 0xffffff,
                size: 1,
                transparent: true,
                opacity: timeOfDay === 'night' ? 0.8 : 0.1
            });
            
            const stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);
        }
        
        // ✨ 파티클 시스템 생성
        function createParticleSystem() {
            console.log('✨ 파티클 시스템 생성 시작...');
            
            // 마법의 먼지 파티클
            const particleCount = 500;
            const particleGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);
            
            for (let i = 0; i < particleCount; i++) {
                // 위치 설정 (도깨비 마을 주변)
                positions[i * 3] = (Math.random() - 0.5) * 80;      // x
                positions[i * 3 + 1] = Math.random() * 20 + 5;     // y (지면 위)
                positions[i * 3 + 2] = (Math.random() - 0.5) * 80; // z
                
                // 색상 설정 (마법같은 색상들)
                const magicColors = [
                    [1.0, 0.8, 1.0], // 분홍
                    [0.8, 1.0, 1.0], // 하늘색
                    [1.0, 1.0, 0.8], // 노랑
                    [0.8, 1.0, 0.8], // 연두
                    [1.0, 0.9, 0.8]  // 주황
                ];
                const colorIndex = Math.floor(Math.random() * magicColors.length);
                colors[i * 3] = magicColors[colorIndex][0];
                colors[i * 3 + 1] = magicColors[colorIndex][1];
                colors[i * 3 + 2] = magicColors[colorIndex][2];
                
                // 크기 설정
                sizes[i] = Math.random() * 2 + 0.5;
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            particleGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            // 파티클 머티리얼
            const particleMaterial = new THREE.PointsMaterial({
                size: 2,
                vertexColors: true,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });
            
            // 파티클 시스템 생성
            const particleSystem = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particleSystem);
            
            // 파티클 애니메이션
            function animateParticles() {
                const positions = particleSystem.geometry.attributes.position.array;
                
                for (let i = 0; i < particleCount; i++) {
                    // 부드럽게 떠다니는 움직임
                    positions[i * 3] += Math.sin(Date.now() * 0.001 + i) * 0.01;     // x
                    positions[i * 3 + 1] += Math.cos(Date.now() * 0.0015 + i) * 0.01; // y
                    positions[i * 3 + 2] += Math.sin(Date.now() * 0.0008 + i) * 0.01; // z
                    
                    // 경계 체크 (파티클이 너무 멀리 가지 않도록)
                    if (Math.abs(positions[i * 3]) > 50) {
                        positions[i * 3] = (Math.random() - 0.5) * 80;
                    }
                    if (positions[i * 3 + 1] > 30 || positions[i * 3 + 1] < 2) {
                        positions[i * 3 + 1] = Math.random() * 20 + 5;
                    }
                    if (Math.abs(positions[i * 3 + 2]) > 50) {
                        positions[i * 3 + 2] = (Math.random() - 0.5) * 80;
                    }
                }
                
                particleSystem.geometry.attributes.position.needsUpdate = true;
            }
            
            // 파티클을 전역 배열에 저장하여 애니메이션에서 사용
            particles.push({ system: particleSystem, animate: animateParticles });
            
            console.log('✨ 파티클 시스템 생성 완료');
        }
        
        // 💎 마법의 크리스털들
        function createMagicCrystals() {
            const crystalColors = [0x4ecdc4, 0xff6b6b, 0x45b7d1, 0x96ceb4, 0xfeca57, 0x9b59b6];
            
            for (let i = 0; i < 12; i++) {
                const crystalGeometry = new THREE.ConeGeometry(0.8, 3, 6);
                const crystalMaterial = new THREE.MeshPhongMaterial({ 
                    color: crystalColors[i % crystalColors.length],
                    transparent: true,
                    opacity: 0.7,
                    emissive: crystalColors[i % crystalColors.length],
                    emissiveIntensity: 0.2
                });
                
                const crystal = new THREE.Mesh(crystalGeometry, crystalMaterial);
                crystal.position.set(
                    (Math.random() - 0.5) * 80,
                    1.5,
                    (Math.random() - 0.5) * 80
                );
                crystal.rotation.y = Math.random() * Math.PI * 2;
                crystal.castShadow = true;
                scene.add(crystal);
            }
        }
        
        // 🏔️ 배경 산들
        function createMountains() {
            for (let i = 0; i < 8; i++) {
                const mountainGeometry = new THREE.ConeGeometry(
                    10 + Math.random() * 10, 
                    20 + Math.random() * 15, 
                    8
                );
                const mountainMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x4a4a4a,
                    transparent: true,
                    opacity: 0.6
                });
                
                const mountain = new THREE.Mesh(mountainGeometry, mountainMaterial);
                const angle = (i / 8) * Math.PI * 2;
                mountain.position.set(
                    Math.cos(angle) * 120,
                    10,
                    Math.sin(angle) * 120
                );
                scene.add(mountain);
            }
        }
        
        // 🌀 중앙 포털
        function createCentralPortal() {
            const portalGeometry = new THREE.RingGeometry(3, 5, 16);
            const portalMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x4ecdc4,
                transparent: true,
                opacity: 0.5,
                side: THREE.DoubleSide
            });
            
            const portal = new THREE.Mesh(portalGeometry, portalMaterial);
            portal.rotation.x = -Math.PI / 2;
            portal.position.y = 0.1;
            scene.add(portal);
            
            // 포털 파티클 효과
            const particleCount = 50;
            const particleGeometry = new THREE.BufferGeometry();
            const particlePositions = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount * 3; i++) {
                particlePositions[i] = (Math.random() - 0.5) * 10;
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
            const particleMaterial = new THREE.PointsMaterial({ 
                color: 0x4ecdc4,
                size: 0.1,
                transparent: true,
                opacity: 0.6
            });
            
            const portalParticles = new THREE.Points(particleGeometry, particleMaterial);
            portalParticles.position.y = 2;
            scene.add(portalParticles);
        }
        
        console.log('🌌 3단계: 고급 3D 환경 구축 완료!');
        
        // � 메인 애니메이션 루프
        function animate() {
            requestAnimationFrame(animate);
            
            // 프레임 카운터 업데이트
            frameCount++;
            const currentTime = performance.now();
            if (currentTime - lastTime > 1000) {
                fps = frameCount;
                frameCount = 0;
                lastTime = currentTime;
            }
            
            // 파티클 애니메이션 실행 (제거됨)
            // particles.forEach(particle => {
            //     if (particle.animate) {
            //         particle.animate();
            //     }
            // });
            
            // 컨트롤 업데이트
            if (controls) {
                controls.update();
            }
            
            // 렌더링
            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
            
            // 성능 모니터링 (개발 모드)
            if (frameCount % 60 === 0) { // 1초마다
                updatePerformanceInfo();
            }
        }
        
        // 📊 성능 정보 업데이트
        function updatePerformanceInfo() {
            const memoryInfo = performance.memory ? {
                used: Math.round(performance.memory.usedJSHeapSize / 1048576),
                total: Math.round(performance.memory.totalJSHeapSize / 1048576),
                limit: Math.round(performance.memory.jsHeapSizeLimit / 1048576)
            } : null;
            
            // 성능 정보를 콘솔에 출력 (디버깅용)
            if (frameCount === 0) { // 1초마다 한 번만
                console.log(`📊 FPS: ${fps}, 도깨비: ${goblins3D.length}/16${memoryInfo ? `, 메모리: ${memoryInfo.used}MB` : ''}`);
            }
        }
        
        // �🏰 16개 도깨비 마을 생성
        function createGoblinVillage() {
            goblinDatabase.forEach((goblinData, index) => {
                // 도깨비 집 생성
                const house = createGoblinHouse(goblinData, index);
                goblinHouses.push(house);
                scene.add(house);
                
                // 3D 도깨비 캐릭터 생성
                const goblin3D = create3DGoblin(goblinData, index);
                goblins3D.push(goblin3D);
                scene.add(goblin3D);
            });
            
            // UI 도깨비 카드들 생성
            createGoblinUI();
            
            updateActiveGoblins();
        }
        
        // 🔄 활성 도깨비 상태 업데이트
        function updateActiveGoblins() {
            // 활성 도깨비 카운트 업데이트
            const activeCount = goblins3D.length;
            
            // UI에서 활성 도깨비 표시 업데이트
            const statusElement = document.querySelector('.system-status');
            if (statusElement) {
                statusElement.innerHTML = `
                    <div>🎮 활성 도깨비: ${activeCount}/16</div>
                    <div>🌍 메타버스 상태: 활성</div>
                    <div>⚡ 시스템: 정상</div>
                `;
            }
            
            // 도깨비들의 AI 행동 시작
            goblins3D.forEach((goblin3D, index) => {
                if (goblin3D && goblin3D.userData) {
                    startGoblinAI(goblin3D, goblinDatabase[index]);
                }
            });
            
            console.log(`✅ ${activeCount}명의 도깨비 활성화 완료`);
        }
        
        // 🏠 개별 도깨비 집 생성
        function createGoblinHouse(goblinData, index) {
            const houseGroup = new THREE.Group();
            
            // 집 기초
            const foundationGeometry = new THREE.BoxGeometry(4, 0.5, 4);
            const foundationMaterial = new THREE.MeshPhongMaterial({ color: 0x8b4513 });
            const foundation = new THREE.Mesh(foundationGeometry, foundationMaterial);
            foundation.position.y = 0.25;
            foundation.castShadow = true;
            foundation.receiveShadow = true;
            houseGroup.add(foundation);
            
            // 집 벽
            const wallGeometry = new THREE.BoxGeometry(3.5, 3, 3.5);
            const wallMaterial = new THREE.MeshPhongMaterial({ 
                color: goblinData.color,
                transparent: true,
                opacity: 0.9
            });
            const walls = new THREE.Mesh(wallGeometry, wallMaterial);
            walls.position.y = 2;
            walls.castShadow = true;
            walls.receiveShadow = true;
            houseGroup.add(walls);
            
            // 지붕
            const roofGeometry = new THREE.ConeGeometry(3, 2.5, 8);
            const roofMaterial = new THREE.MeshPhongMaterial({ color: 0x654321 });
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.position.y = 4.75;
            roof.castShadow = true;
            houseGroup.add(roof);
            
            // 문
            const doorGeometry = new THREE.BoxGeometry(0.8, 2, 0.1);
            const doorMaterial = new THREE.MeshPhongMaterial({ color: 0x4a4a4a });
            const door = new THREE.Mesh(doorGeometry, doorMaterial);
            door.position.set(0, 1.5, 1.76);
            houseGroup.add(door);
            
            // 창문들
            for (let i = 0; i < 2; i++) {
                const windowGeometry = new THREE.BoxGeometry(0.6, 0.6, 0.1);
                const windowMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x87CEEB,
                    transparent: true,
                    opacity: 0.7
                });
                const window = new THREE.Mesh(windowGeometry, windowMaterial);
                window.position.set((i === 0 ? -1 : 1), 2.5, 1.76);
                houseGroup.add(window);
            }
            
            // 굴뚝
            const chimneyGeometry = new THREE.BoxGeometry(0.4, 1.5, 0.4);
            const chimneyMaterial = new THREE.MeshPhongMaterial({ color: 0x8b4513 });
            const chimney = new THREE.Mesh(chimneyGeometry, chimneyMaterial);
            chimney.position.set(1.2, 5.75, 1.2);
            chimney.castShadow = true;
            houseGroup.add(chimney);
            
            // 연기 파티클 (굴뚝용)
            if (Math.random() > 0.5) {
                const smokeParticles = createSmokeEffect();
                smokeParticles.position.set(1.2, 6.5, 1.2);
                houseGroup.add(smokeParticles);
            }
            
            // 집 앞 장식
            const decorationGeometry = new THREE.SphereGeometry(0.3, 8, 8);
            const decorationMaterial = new THREE.MeshPhongMaterial({ 
                color: goblinData.color,
                emissive: goblinData.color,
                emissiveIntensity: 0.3
            });
            const decoration = new THREE.Mesh(decorationGeometry, decorationMaterial);
            decoration.position.set(0, 1, 2.5);
            decoration.castShadow = true;
            houseGroup.add(decoration);
            
            // 집 위치 설정
            houseGroup.position.set(goblinData.position.x, 0, goblinData.position.z);
            houseGroup.userData = { goblinData: goblinData, type: 'house' };
            
            return houseGroup;
        }
        
        // 🧙‍♂️ 3D 도깨비 캐릭터 생성
        function create3DGoblin(goblinData, index) {
            const goblinGroup = new THREE.Group();
            
            // 도깨비 몸체 (구)
            const bodyGeometry = new THREE.SphereGeometry(0.8, 16, 16);
            const bodyMaterial = new THREE.MeshPhongMaterial({ 
                color: goblinData.color,
                shininess: 30
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.8;
            body.castShadow = true;
            goblinGroup.add(body);
            
            // 도깨비 머리 (더 큰 구)
            const headGeometry = new THREE.SphereGeometry(0.6, 16, 16);
            const baseColor = new THREE.Color(goblinData.color);
            // 안정적인 색상 조정
            const headColor = baseColor.clone().multiplyScalar(1.2);
            const headMaterial = new THREE.MeshPhongMaterial({ 
                color: headColor
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 2;
            head.castShadow = true;
            goblinGroup.add(head);
            
            // 눈들
            for (let i = 0; i < 2; i++) {
                const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const eyeMaterial = new THREE.MeshPhongMaterial({ color: 0xffffff });
                const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                eye.position.set((i === 0 ? -0.2 : 0.2), 2.2, 0.5);
                goblinGroup.add(eye);
                
                // 눈동자
                const pupilGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                const pupilMaterial = new THREE.MeshPhongMaterial({ color: 0x000000 });
                const pupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                pupil.position.set((i === 0 ? -0.2 : 0.2), 2.2, 0.55);
                goblinGroup.add(pupil);
            }
            
            // 모자 (원뿔)
            const hatGeometry = new THREE.ConeGeometry(0.5, 1.2, 8);
            const hatMaterial = new THREE.MeshPhongMaterial({ color: 0x4a4a4a });
            const hat = new THREE.Mesh(hatGeometry, hatMaterial);
            hat.position.y = 2.8;
            hat.castShadow = true;
            goblinGroup.add(hat);
            
            // 팔들
            for (let i = 0; i < 2; i++) {
                // 안정적인 CylinderGeometry 사용
                const armGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.8, 8);
                const baseColor = new THREE.Color(goblinData.color);
                // 색상 조정 (multiplyScalar 사용)
                const armColor = baseColor.clone().multiplyScalar(1.1);
                const armMaterial = new THREE.MeshPhongMaterial({ 
                    color: armColor
                });
                const arm = new THREE.Mesh(armGeometry, armMaterial);
                arm.position.set((i === 0 ? -1 : 1), 1.2, 0);
                arm.rotation.z = (i === 0 ? 0.3 : -0.3);
                arm.castShadow = true;
                goblinGroup.add(arm);
            }
            
            // 다리들
            for (let i = 0; i < 2; i++) {
                // 안정적인 CylinderGeometry 사용
                const legGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.6, 8);
                const baseColor = new THREE.Color(goblinData.color);
                // 색상 조정 (multiplyScalar 사용)
                const legColor = baseColor.clone().multiplyScalar(0.9);
                const legMaterial = new THREE.MeshPhongMaterial({ 
                    color: legColor
                });
                const leg = new THREE.Mesh(legGeometry, legMaterial);
                leg.position.set((i === 0 ? -0.3 : 0.3), 0.3, 0);
                leg.castShadow = true;
                goblinGroup.add(leg);
            }
            
            // 마법 오라 효과
            const auraGeometry = new THREE.RingGeometry(1.5, 2, 16);
            const auraMaterial = new THREE.MeshBasicMaterial({ 
                color: goblinData.color,
                transparent: true,
                opacity: 0.2,
                side: THREE.DoubleSide
            });
            const aura = new THREE.Mesh(auraGeometry, auraMaterial);
            aura.rotation.x = -Math.PI / 2;
            aura.position.y = 0.1;
            goblinGroup.add(aura);
            
            // 도깨비 위치 설정 (집 앞)
            goblinGroup.position.set(
                goblinData.position.x + (Math.random() - 0.5) * 2,
                0,
                goblinData.position.z + 3
            );
            
            goblinGroup.userData = { 
                goblinData: goblinData, 
                type: 'goblin',
                animationOffset: Math.random() * Math.PI * 2
            };
            
            return goblinGroup;
        }
        
        // 💨 연기 효과 생성
        function createSmokeEffect() {
            const smokeGeometry = new THREE.BufferGeometry();
            const smokeCount = 20;
            const positions = new Float32Array(smokeCount * 3);
            
            for (let i = 0; i < smokeCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 0.5;
                positions[i * 3 + 1] = Math.random() * 2;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 0.5;
            }
            
            smokeGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const smokeMaterial = new THREE.PointsMaterial({ 
                color: 0x888888,
                size: 0.3,
                transparent: true,
                opacity: 0.5
            });
            
            return new THREE.Points(smokeGeometry, smokeMaterial);
        }
        
        // 🎨 UI 도깨비 카드들 생성
        function createGoblinUI() {
            const goblinGrid = document.getElementById('goblinGrid');
            goblinGrid.innerHTML = '';
            
            goblinDatabase.forEach((goblin, index) => {
                const card = document.createElement('div');
                card.className = 'goblin-card';
                card.onclick = () => focusOnGoblin(index);
                
                card.innerHTML = `
                    <div class="goblin-avatar">${goblin.emoji}</div>
                    <div class="goblin-name">${goblin.name}</div>
                    <div class="goblin-role">${goblin.role}</div>
                    <div class="goblin-status">💚 활성</div>
                `;
                
                goblinGrid.appendChild(card);
            });
        }
        
        console.log('🌌 4단계: 16개 도깨비 집과 캐릭터 생성 완료!');
        
        // 🎮 이벤트 리스너 설정
        function setupEventListeners() {
            const canvas = document.getElementById('metaverse-canvas');
            
            // 클릭 이벤트 (도깨비 선택)
            canvas.addEventListener('click', onCanvasClick);
            
            // 키보드 이벤트
            document.addEventListener('keydown', onKeyDown);
            
            // 윈도우 리사이즈
            window.addEventListener('resize', onWindowResize);
        }
        
        // 🖱️ 캔버스 클릭 처리
        function onCanvasClick(event) {
            if (!camera || !goblins3D || goblins3D.length === 0) return; // 안전장치
            
            const mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            
            // 도깨비들과의 교차 검사
            const goblinMeshes = goblins3D.flatMap(group => group.children);
            const intersects = raycaster.intersectObjects(goblinMeshes);
            
            if (intersects.length > 0) {
                const clickedObject = intersects[0].object.parent;
                const goblinData = clickedObject.userData.goblinData;
                
                if (goblinData) {
                    selectGoblin(goblinData);
                    openChat(goblinData);
                }
            }
        }
        
        // ⌨️ 키보드 이벤트 처리
        function onKeyDown(event) {
            switch(event.key) {
                case 'Escape':
                    closeChat();
                    break;
                case ' ':
                    toggleAutoRotate();
                    event.preventDefault();
                    break;
                case 't':
                case 'T':
                    toggleDay();
                    break;
                case 'w':
                case 'W':
                    toggleWeather();
                    break;
                case 'r':
                case 'R':
                    resetCamera();
                    break;
            }
        }
        
        // 📱 윈도우 리사이즈 처리
        function onWindowResize() {
            if (!camera || !renderer) return; // 안전장치
            
            const canvas = document.getElementById('metaverse-canvas');
            if (!canvas) return; // 캔버스 확인
            
            camera.aspect = canvas.offsetWidth / canvas.offsetHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(canvas.offsetWidth, canvas.offsetHeight);
        }
        
        // 🎯 도깨비 선택 및 포커스
        function selectGoblin(goblinData) {
            const goblinIndex = goblinDatabase.findIndex(g => g.id === goblinData.id);
            const goblin3D = goblins3D[goblinIndex];
            
            if (goblin3D) {
                // 도깨비 하이라이트 애니메이션
                gsap.to(goblin3D.scale, {
                    x: 1.2, y: 1.2, z: 1.2,
                    duration: 0.3,
                    yoyo: true,
                    repeat: 1,
                    ease: "power2.inOut"
                });
                
                // 카메라를 도깨비에게 포커스
                focusOnGoblin(goblinIndex);
            }
        }
        
        // 📷 도깨비에게 카메라 포커스
        function focusOnGoblin(index) {
            const goblin = goblins3D[index];
            if (goblin) {
                const targetPosition = {
                    x: goblin.position.x + 5,
                    y: goblin.position.y + 3,
                    z: goblin.position.z + 5
                };
                
                gsap.to(camera.position, {
                    ...targetPosition,
                    duration: 1.5,
                    ease: "power2.inOut"
                });
                
                gsap.to(controls.target, {
                    x: goblin.position.x,
                    y: goblin.position.y + 1,
                    z: goblin.position.z,
                    duration: 1.5,
                    ease: "power2.inOut",
                    onUpdate: () => controls.update()
                });
            }
        }
        
        // 💬 채팅창 열기
        function openChat(goblinData) {
            currentGoblin = goblinData;
            
            document.getElementById('chatEmoji').textContent = goblinData.emoji;
            document.getElementById('chatTitle').textContent = goblinData.name;
            document.getElementById('chatSubtitle').textContent = goblinData.role;
            
            // 초기 메시지
            const messagesContainer = document.getElementById('chatMessages');
            messagesContainer.innerHTML = `
                <div class="message goblin">
                    <div class="message-bubble">
                        안녕하세요! ${goblinData.name}입니다. ${goblinData.specialties.join(', ')} 분야의 전문가예요. 
                        무엇을 도와드릴까요? 😊
                    </div>
                </div>
            `;
            
            document.getElementById('chatOverlay').style.display = 'flex';
            document.getElementById('chatInput').focus();
            
            conversationCount++;
            updateConversationCount();
        }
        
        // 💬 채팅창 닫기
        function closeChat() {
            document.getElementById('chatOverlay').style.display = 'none';
            currentGoblin = null;
        }
        
        // ⌨️ 채팅 입력 처리
        function handleKeyPress(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendMessage();
            }
        }
        
        // 📤 메시지 전송
        function sendMessage() {
            const input = document.getElementById('chatInput');
            const message = input.value.trim();
            
            if (!message || !currentGoblin) return;
            
            // 사용자 메시지 추가
            addMessage('user', message);
            
            // 전송 버튼 로딩 상태
            const sendButton = document.getElementById('sendButtonText');
            sendButton.innerHTML = '<div class="loading-spinner"></div>';
            
            // AI 응답 생성 (1-2초 지연으로 현실적인 대화감)
            setTimeout(() => {
                const response = generateAdvancedAIResponse(currentGoblin, message);
                addMessage('goblin', response);
                sendButton.textContent = '전송';
            }, 1000 + Math.random() * 1000);
            
            input.value = '';
        }
        
        // 💬 메시지 추가
        function addMessage(sender, text) {
            const messagesContainer = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${sender}`;
            messageDiv.innerHTML = `<div class="message-bubble">${text}</div>`;
            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }
        
        // 🤖 고급 AI 응답 생성 (기존 도깨비들과 매칭)
        function generateAdvancedAIResponse(goblinData, input) {
            const userInput = input.toLowerCase();
            const specialties = goblinData.specialties;
            const goblinName = goblinData.name;
            
            // 도깨비 이름 기반 응답 분기
            switch(goblinName) {
                case '의료':
                    return generateMedicalResponse(input);
                case '빌더':
                    return generateTechResponse(input);
                case '상담':
                    return generatePsychologyResponse(input);
                case '창작':
                    return generateCreativeResponse(input);
                case '데이터분석':
                    return generateDataResponse(input);
                case 'SEO':
                    return generateSEOResponse(input);
                case '마케팅':
                    return generateMarketingResponse(input);
                case '글쓰기':
                    return generateWritingResponse(input);
                case '컨설팅':
                    return generateBusinessResponse(input);
                case '인사':
                    return generateHRResponse(input);
                case '비서':
                    return generateAssistantResponse(input);
                case '창업':
                    return generateStartupResponse(input);
                case '쇼핑':
                    return generateShoppingResponse(input);
                case '성장':
                    return generateGrowthResponse(input);
                case '운세':
                    return generateFortuneResponse(input);
                case '촌장':
                    return generateWiseResponse(input);
                default:
                    return generateWiseResponse(input);
            }
        }
        
        // 🏥 의료 응답
        function generateMedicalResponse(input) {
            return `🏥 **의료 전문 분석**

**🔍 증상 검토**: "${input}"

**📋 전문 조치사항**:
• 1단계: 충분한 휴식과 수분 섭취
• 2단계: 증상 모니터링 (24-48시간)
• 3단계: 지속시 전문의 상담 필수

**⚠️ 주의사항**: 급작스러운 악화시 즉시 응급실 방문

**💡 예방 관리법**:
✅ 규칙적인 생활패턴 유지
✅ 적절한 운동과 영양 관리
✅ 스트레스 관리 및 충분한 수면

더 구체적인 증상이나 상황을 말씀해주시면 정밀 분석해드리겠습니다.`;
        }
        
        // 💼 비즈니스 응답
        function generateBusinessResponse(input) {
            return `💼 **비즈니스 전략 분석**

**🎯 현황 분석**: "${input}"

**⚡ 핵심 전략**:
• **우선순위 매트릭스**: 중요도 × 긴급도 분석
• **리소스 최적화**: 20% 핵심업무에 80% 투자
• **성과 지표**: 명확한 KPI 설정 및 추적

**🚀 실행 방안**:
1️⃣ 단기 목표: 즉시 실행 가능한 개선사항
2️⃣ 중기 전략: 3-6개월 로드맵 수립
3️⃣ 장기 비전: 1년 후 목표 달성 계획

**📊 성공 지표**: ROI, 생산성, 팀 만족도 등을 통한 지속적 모니터링

구체적인 업무 상황을 공유해주시면 맞춤형 솔루션을 제시해드리겠습니다.`;
        }
        
        // 🔧 기술 응답
        function generateTechResponse(input) {
            return `🔧 **기술 솔루션 분석**

**💻 기술 검토**: "${input}"

**🛠️ 권장 솔루션**:
• **아키텍처**: 확장 가능한 모듈형 설계
• **기술 스택**: 최신 프레임워크 및 도구 활용
• **성능 최적화**: 캐싱, CDN, 데이터베이스 튜닝

**⚡ 개발 프로세스**:
1️⃣ 요구사항 분석 및 기술 검토
2️⃣ 프로토타입 개발 및 테스트
3️⃣ 반복적 개발 및 배포 (CI/CD)

**🔍 품질 보장**: 코드 리뷰, 자동화 테스트, 모니터링 시스템

프로젝트의 구체적인 요구사항을 알려주시면 상세한 기술 설계안을 제공해드리겠습니다.`;
        }
        
        // 💭 심리 응답
        function generatePsychologyResponse(input) {
            return `💭 **심리 상담 분석**

**🧠 감정 상태**: "${input}"

**🌟 마음챙김 접근법**:
• **현재 순간 집중**: 5-4-3-2-1 그라운딩 기법
• **감정 수용**: 판단하지 않고 있는 그대로 인정
• **호흡 조절**: 4-7-8 호흡법으로 마음 안정

**💪 대처 전략**:
1️⃣ 즉시 안정화: 깊은 호흡 및 긴장 완화
2️⃣ 인지 재구성: 부정적 사고 패턴 전환
3️⃣ 행동 계획: 구체적이고 실현 가능한 단계

**🤝 지지 체계**: 가족, 친구, 전문가와의 소통 활성화

어떤 감정이나 상황인지 더 자세히 말씀해주시면 개인맞춤 솔루션을 제공해드리겠습니다.`;
        }
        
        // 🎨 창의성 응답
        function generateCreativeResponse(input) {
            return `🎨 **창의적 솔루션 개발**

**✨ 아이디어 탐색**: "${input}"

**🌟 창의적 사고 기법**:
• **브레인스토밍**: 자유로운 아이디어 발산
• **SCAMPER**: 체계적 창의 프로세스
• **마인드맵**: 시각적 연상 확장

**🚀 혁신 프로세스**:
1️⃣ 문제 재정의: 다른 관점에서 접근
2️⃣ 아이디어 융합: 서로 다른 개념 결합
3️⃣ 프로토타입: 빠른 시험 및 개선

**🎯 실행 전략**: 작은 실험부터 시작하여 점진적 확장

창의적 프로젝트나 아이디어에 대해 더 구체적으로 말씀해주시면 맞춤형 창작 지원을 해드리겠습니다.`;
        }
        
        // 📊 데이터 응답  
        function generateDataResponse(input) {
            return `📊 **데이터 분석 인사이트**

**🔍 분석 요청**: "${input}"

**📈 분석 프로세스**:
• **데이터 수집**: 관련성 높은 정보 확보
• **전처리**: 정제, 변환, 결측치 처리
• **시각화**: 패턴 및 트렌드 발견

**⚡ 분석 도구**:
1️⃣ 통계 분석: Python/R 기반 분석
2️⃣ 머신러닝: 예측 모델 구축
3️⃣ 시각화: 대시보드 및 리포트

**🎯 실행 가능한 인사이트**: 비즈니스 의사결정 지원

데이터나 분석 목표를 구체적으로 알려주시면 맞춤형 분석 방법론을 제시해드리겠습니다.`;
        }
        
        function generateFinanceResponse(input) {
            return `💰 **금융 투자 분석**

**💹 투자 검토**: "${input}"

**📊 투자 전략**:
• **리스크 관리**: 분산투자 및 포트폴리오 구성
• **자산 배분**: 연령, 목표에 따른 최적화
• **시장 분석**: 경제 지표 및 트렌드 파악

**⚡ 실행 단계**:
1️⃣ 재정 현황 분석 및 목표 설정
2️⃣ 투자 상품 선별 및 비교
3️⃣ 정기적 모니터링 및 리밸런싱

**🎯 장기 전략**: 복리 효과 극대화 및 인플레이션 대응

투자 목표나 현재 상황을 더 자세히 알려주시면 맞춤형 포트폴리오를 제안해드리겠습니다.`;
        }
        
        // 📈 마케팅 응답
        function generateMarketingResponse(input) {
            return `📈 **마케팅 전략 및 브랜딩**

**🎯 마케팅 분석**: "${input}"

**🚀 핵심 마케팅 전략**:
• **타겟 분석**: 고객 페르소나 및 시장 세분화
• **채널 최적화**: SNS, 콘텐츠, 퍼포먼스 마케팅
• **브랜드 포지셔닝**: 차별화된 브랜드 가치 전달

**⚡ 실행 계획**:
1️⃣ 시장 조사 및 경쟁사 분석
2️⃣ 통합 마케팅 전략 수립
3️⃣ 캠페인 실행 및 성과 측정

**📊 성과 지표**: 브랜드 인지도, 리드 생성, 전환율 향상

어떤 제품이나 서비스인지 알려주시면 맞춤형 마케팅 솔루션을 제공해드리겠습니다.`;
        }
        
        // 기타 응답 함수들도 비슷하게 구현...
        function generateSEOResponse(input) {
            return `🔍 **SEO 최적화 전략**

**📊 현재 상황 분석**: "${input}"

**🎯 핵심 SEO 전략**:
• **키워드 연구**: 검색량 높은 타겟 키워드 발굴
• **콘텐츠 최적화**: 사용자 의도에 맞는 고품질 콘텐츠
• **기술적 SEO**: 페이지 속도, 모바일 최적화, 구조화된 데이터

**⚡ 실행 단계**:
1️⃣ 키워드 분석 및 경쟁사 조사
2️⃣ 온페이지 최적화 및 콘텐츠 개선
3️⃣ 백링크 구축 및 기술적 개선

**📈 성과 측정**: 검색 순위, 트래픽, 전환율 모니터링

구체적인 웹사이트나 목표를 알려주시면 맞춤형 SEO 전략을 제시해드리겠습니다.`;
        }
        
        function generateWritingResponse(input) {
            return `✍️ **글쓰기 마스터 가이드**

**� 글쓰기 요청**: "${input}"

**🎯 효과적인 글쓰기 전략**:
• **구조화**: 서론-본론-결론의 명확한 구성
• **독자 중심**: 타겟 독자의 관심사와 수준 고려
• **스토리텔링**: 감정적 연결을 만드는 이야기 구조

**⚡ 글쓰기 프로세스**:
1️⃣ 목적과 독자 정의 및 아웃라인 작성
2️⃣ 핵심 메시지 중심의 초안 작성
3️⃣ 퇴고 및 최종 편집

**💡 실용 팁**: 간결함, 구체성, 독창성을 통한 글의 완성도 향상

어떤 종류의 글을 쓰시는지 알려주시면 더 구체적인 가이드를 제공해드리겠습니다.`;
        }
        
        function generateHRResponse(input) {
            return `👥 **인사 관리 솔루션**

**🔍 인사 이슈**: "${input}"

**💼 효과적인 인사 전략**:
• **채용**: 적합한 인재 발굴 및 선발 시스템
• **개발**: 직원 성장을 위한 교육 및 멘토링
• **평가**: 공정하고 투명한 성과 관리 체계

**⚡ 실행 방안**:
1️⃣ 조직 분석 및 인력 계획 수립
2️⃣ 채용 프로세스 최적화 및 온보딩
3️⃣ 성과 관리 및 경력 개발 지원

**🎯 성공 지표**: 직원 만족도, 유지율, 생산성 향상

구체적인 조직 상황을 공유해주시면 맞춤형 인사 솔루션을 제안해드리겠습니다.`;
        }
        
        function generateAssistantResponse(input) {
            return `🤖 **업무 효율화 솔루션**

**⚡ 업무 요청**: "${input}"

**🎯 효율성 향상 전략**:
• **자동화**: 반복 업무의 시스템화 및 도구 활용
• **우선순위**: 중요도와 긴급도에 따른 업무 분류
• **시간 관리**: 집중 시간 확보 및 일정 최적화

**⚡ 실행 도구**:
1️⃣ 프로젝트 관리: Notion, Trello, Asana 활용
2️⃣ 의사소통: Slack, Teams를 통한 효율적 협업
3️⃣ 자동화: Zapier, Power Automate로 반복 작업 해결

**📊 성과 측정**: 업무 처리 시간 단축 및 품질 향상

어떤 업무를 개선하고 싶으신지 알려주시면 구체적인 효율화 방안을 제시해드리겠습니다.`;
        }
        
        function generateStartupResponse(input) {
            return `🚀 **창업 성공 로드맵**

**💡 창업 아이디어**: "${input}"

**🎯 성공적인 창업 전략**:
• **시장 검증**: 고객 니즈 파악 및 MVP 테스트
• **비즈니스 모델**: 수익 구조 설계 및 경쟁력 확보
• **자금 조달**: 투자 유치 및 재정 관리 계획

**⚡ 단계별 실행**:
1️⃣ 아이디어 검증 및 시장 조사
2️⃣ 사업 계획서 작성 및 팀 구성
3️⃣ 프로토타입 개발 및 초기 고객 확보

**💰 성장 전략**: 스케일업을 위한 마케팅 및 운영 체계 구축

창업 분야나 현재 단계를 알려주시면 맞춤형 창업 전략을 제공해드리겠습니다.`;
        }
        
        function generateShoppingResponse(input) {
            return `🛍️ **스마트 쇼핑 가이드**

**🔍 쇼핑 요청**: "${input}"

**💰 현명한 구매 전략**:
• **비교 분석**: 가격, 품질, 리뷰를 종합한 제품 비교
• **타이밍**: 할인 시기 및 시즌별 최적 구매 시점
• **브랜드 신뢰도**: AS, 보증, 사용자 후기 검토

**⚡ 구매 프로세스**:
1️⃣ 니즈 분석 및 예산 설정
2️⃣ 제품 비교 및 리뷰 분석
3️⃣ 최적 타이밍 구매 및 사후 관리

**🎁 추가 혜택**: 쿠폰, 적립금, 멤버십 혜택 활용법

구체적인 제품이나 쇼핑 목적을 알려주시면 맞춤형 구매 가이드를 제공해드리겠습니다.`;
        }
        
        function generateGrowthResponse(input) {
            return `🌱 **개인 성장 로드맵**

**🎯 성장 목표**: "${input}"

**🚀 체계적인 성장 전략**:
• **목표 설정**: SMART 원칙에 따른 구체적 목표 수립
• **습관 형성**: 작은 변화를 통한 지속 가능한 성장
• **피드백**: 정기적 점검 및 방향 조정

**⚡ 성장 프로세스**:
1️⃣ 현재 상태 분석 및 목표 명확화
2️⃣ 실행 계획 수립 및 일일 루틴 구축
3️⃣ 지속적 모니터링 및 개선

**💪 동기 유지**: 성취 기록, 보상 시스템, 성장 커뮤니티 참여

어떤 분야에서 성장하고 싶으신지 알려주시면 개인맞춤 성장 계획을 세워드리겠습니다.`;
        }
        
        function generateFortuneResponse(input) {
            return `🔮 **운세 및 미래 인사이트**

**✨ 운세 요청**: "${input}"

**🌟 오늘의 운세 해석**:
• **종합 운**: 전반적인 에너지와 흐름 분석
• **인간관계**: 대인관계에서의 주의점과 기회
• **일과 성공**: 업무와 목표 달성을 위한 조언

**⚡ 긍정적 변화 가이드**:
1️⃣ 현재 상황에 대한 통찰과 해석
2️⃣ 앞으로의 기회와 주의사항
3️⃣ 운을 더 좋게 만드는 실천 방법

**🍀 행운 팁**: 긍정적 마인드, 감사한 마음, 적극적 행동으로 운명 개선

구체적인 고민이나 궁금한 분야를 말씀해주시면 더 자세한 운세를 봐드리겠습니다.`;
        }
        
        function generateEducationResponse(input) {
            return `� **학습 설계 및 멘토링**

효과적인 학습 방법과 개인맞춤 교육 계획을 제공해드리겠습니다.

"${input}"에 대한 체계적인 학습 로드맵을 함께 만들어보세요!`;
        }
        
        function generateLegalResponse(input) {
            return `⚖️ **법률 자문 및 해석**

법적 이슈에 대한 전문적인 분석과 대응 방안을 제시해드리겠습니다.

"${input}" 관련하여 법적 검토 및 조치사항을 안내해드리겠습니다.`;
        }
        
        function generateWellnessResponse(input) {
            return `🧘 **웰니스 및 라이프스타일**

건강한 삶을 위한 종합적인 웰니스 솔루션을 제공해드리겠습니다.

"${input}"를 통해 더 나은 라이프스타일을 만들어가세요!`;
        }
        
        function generateTravelResponse(input) {
            return `🗺️ **여행 계획 및 문화 탐방**

완벽한 여행 계획과 현지 문화 체험 가이드를 제공해드리겠습니다.

"${input}" 관련하여 특별한 여행 경험을 설계해보세요!`;
        }
        
        function generateLanguageResponse(input) {
            return `🌍 **언어 학습 및 다문화 소통**

효과적인 언어 학습법과 문화간 소통 전략을 제공해드리겠습니다.

"${input}"를 통해 글로벌 소통 능력을 향상시켜보세요!`;
        }
        
        function generateCareerResponse(input) {
            return `🎯 **커리어 개발 및 진로 설계**

성공적인 커리어 발전을 위한 맞춤형 전략을 제공해드리겠습니다.

"${input}" 관련하여 커리어 로드맵을 함께 설계해보세요!`;
        }
        
        function generateRelationshipResponse(input) {
            return `💝 **인간관계 및 소통 개선**

건강한 관계 구축과 효과적인 소통 전략을 제공해드리겠습니다.

"${input}"를 통해 더 나은 인간관계를 만들어가세요!`;
        }
        
        function generateWiseResponse(input) {
            return `👴 **마을 촌장의 지혜**

오랜 경험과 지혜로 모든 문제에 대한 통찰을 제공해드리겠습니다.

"${input}"에 대해 함께 깊이 생각해보고 지혜로운 해답을 찾아보세요.

**🌟 삶의 지혜**:
• 모든 문제에는 반드시 해결책이 있습니다
• 때로는 다른 관점에서 보는 것이 필요합니다
• 작은 변화가 큰 결과를 만들어냅니다`;
        }
        
        // 🤖 도깨비 AI 시스템 시작
        function startGoblinAI(goblin3D, goblinData) {
            if (!goblin3D || !goblinData) return;
            
            // 도깨비 AI 행동 데이터 초기화
            goblin3D.userData.aiState = {
                isActive: true,
                lastAction: Date.now(),
                currentMood: 'happy',
                interactionCount: 0,
                specialties: goblinData.specialties || []
            };
            
            // 랜덤 AI 행동 시작
            const behaviorInterval = setInterval(() => {
                if (!goblin3D.userData.aiState.isActive) {
                    clearInterval(behaviorInterval);
                    return;
                }
                
                // 랜덤 행동 선택
                const actions = ['wave', 'bounce', 'rotate', 'glow'];
                const randomAction = actions[Math.floor(Math.random() * actions.length)];
                
                performGoblinAction(goblin3D, randomAction);
                
            }, 5000 + Math.random() * 10000); // 5-15초마다 행동
            
            console.log(`🤖 ${goblinData.name} 도깨비 AI 활성화`);
        }
        
        // 🎭 도깨비 행동 실행
        function performGoblinAction(goblin3D, action) {
            if (!goblin3D || !gsap) return;
            
            switch(action) {
                case 'wave':
                    // 손 흔들기 (회전 애니메이션)
                    gsap.to(goblin3D.rotation, {
                        z: goblin3D.rotation.z + 0.3,
                        duration: 0.5,
                        yoyo: true,
                        repeat: 3
                    });
                    break;
                    
                case 'bounce':
                    // 통통 튀기
                    gsap.to(goblin3D.position, {
                        y: goblin3D.position.y + 1,
                        duration: 0.5,
                        yoyo: true,
                        repeat: 1,
                        ease: "bounce.out"
                    });
                    break;
                    
                case 'rotate':
                    // 한 바퀴 돌기
                    gsap.to(goblin3D.rotation, {
                        y: goblin3D.rotation.y + Math.PI * 2,
                        duration: 2,
                        ease: "power2.inOut"
                    });
                    break;
                    
                case 'glow':
                    // 반짝이기 (색상 변화)
                    if (goblin3D.children[0] && goblin3D.children[0].material) {
                        const originalColor = goblin3D.children[0].material.color.getHex();
                        goblin3D.children[0].material.color.setHex(0xffffff);
                        setTimeout(() => {
                            goblin3D.children[0].material.color.setHex(originalColor);
                        }, 500);
                    }
                    break;
            }
        }
        
        
        // 🎮 애니메이션 및 상호작용 시스템
        function startAnimationSystem() {
            // 도깨비들의 자동 애니메이션
            goblins3D.forEach((goblin, index) => {
                const goblinData = goblinDatabase[index];
                
                // 떠다니는 애니메이션
                gsap.to(goblin.position, {
                    y: goblin.position.y + 0.3,
                    duration: 2 + Math.random() * 2,
                    yoyo: true,
                    repeat: -1,
                    ease: "sine.inOut",
                    delay: Math.random() * 2
                });
                
                // 회전 애니메이션
                gsap.to(goblin.rotation, {
                    y: goblin.rotation.y + Math.PI * 2,
                    duration: 10 + Math.random() * 10,
                    repeat: -1,
                    ease: "none"
                });
                
                // 도깨비별 특별 효과
                setTimeout(() => {
                    addGoblinSpecialEffects(goblin, goblinData);
                }, index * 500);
            });
        }
        
        // ✨ 도깨비별 특별 효과
        function addGoblinSpecialEffects(goblin, goblinData) {
            const specialties = goblinData.specialties;
            
            // 의료 도깨비 - 힐링 오라
            if (specialties.includes('건강') || specialties.includes('의학')) {
                addHealingAura(goblin);
            }
            // 기술 도깨비 - 디지털 파티클
            else if (specialties.includes('개발') || specialties.includes('기술')) {
                addTechParticles(goblin);
            }
            // 창의 도깨비 - 무지개 효과
            else if (specialties.includes('창의성') || specialties.includes('디자인')) {
                addRainbowEffect(goblin);
            }
            // 금융 도깨비 - 골드 이펙트
            else if (specialties.includes('투자') || specialties.includes('금융')) {
                addGoldEffect(goblin);
            }
            // 기본 마법 오라
            else {
                addMagicalAura(goblin);
            }
        }
        
        // � 힐링 오라 효과
        function addHealingAura(goblin) {
            const geometry = new THREE.RingGeometry(0.5, 1, 16);
            const material = new THREE.MeshBasicMaterial({
                color: 0x00ff88,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide
            });
            
            const aura = new THREE.Mesh(geometry, material);
            aura.rotation.x = Math.PI / 2;
            aura.position.y = -0.5;
            goblin.add(aura);
            
            gsap.to(aura.rotation, {
                z: Math.PI * 2,
                duration: 4,
                repeat: -1,
                ease: "none"
            });
        }
        
        // ⚡ 디지털 파티클 효과
        function addTechParticles(goblin) {
            const particleCount = 20;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 2;
                positions[i * 3 + 1] = Math.random() * 2;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 2;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const material = new THREE.PointsMaterial({
                color: 0x00aaff,
                size: 0.05,
                transparent: true,
                opacity: 0.8
            });
            
            const particles = new THREE.Points(geometry, material);
            goblin.add(particles);
            
            gsap.to(particles.rotation, {
                y: Math.PI * 2,
                duration: 3,
                repeat: -1,
                ease: "none"
            });
        }
        
        // 🌈 무지개 효과
        function addRainbowEffect(goblin) {
            const geometry = new THREE.SphereGeometry(1.2, 16, 8);
            const material = new THREE.MeshBasicMaterial({
                color: 0xff6b6b,
                transparent: true,
                opacity: 0.1,
                wireframe: true
            });
            
            const rainbow = new THREE.Mesh(geometry, material);
            goblin.add(rainbow);
            
            gsap.to(rainbow.material, {
                opacity: 0.3,
                duration: 2,
                yoyo: true,
                repeat: -1,
                ease: "sine.inOut"
            });
            
            // 색상 변화
            let hue = 0;
            const updateColor = () => {
                hue += 0.01;
                rainbow.material.color.setHSL(hue % 1, 1, 0.5);
                requestAnimationFrame(updateColor);
            };
            updateColor();
        }
        
        // 💰 골드 이펙트
        function addGoldEffect(goblin) {
            const coins = [];
            for (let i = 0; i < 5; i++) {
                const geometry = new THREE.CylinderGeometry(0.1, 0.1, 0.02, 8);
                const material = new THREE.MeshBasicMaterial({ color: 0xffd700 });
                const coin = new THREE.Mesh(geometry, material);
                
                coin.position.set(
                    (Math.random() - 0.5) * 2,
                    Math.random() * 2 + 1,
                    (Math.random() - 0.5) * 2
                );
                
                goblin.add(coin);
                coins.push(coin);
                
                gsap.to(coin.rotation, {
                    y: Math.PI * 2,
                    duration: 1 + Math.random(),
                    repeat: -1,
                    ease: "none"
                });
                
                gsap.to(coin.position, {
                    y: coin.position.y + 0.5,
                    duration: 2,
                    yoyo: true,
                    repeat: -1,
                    ease: "sine.inOut",
                    delay: i * 0.2
                });
            }
        }
        
        // ✨ 기본 마법 오라
        function addMagicalAura(goblin) {
            const geometry = new THREE.SphereGeometry(0.8, 8, 6);
            const material = new THREE.MeshBasicMaterial({
                color: 0x9b59b6,
                transparent: true,
                opacity: 0.15,
                wireframe: true
            });
            
            const aura = new THREE.Mesh(geometry, material);
            goblin.add(aura);
            
            gsap.to(aura.scale, {
                x: 1.2, y: 1.2, z: 1.2,
                duration: 3,
                yoyo: true,
                repeat: -1,
                ease: "sine.inOut"
            });
        }
        
        // 🎮 컨트롤 기능들
        function toggleAutoRotate() {
            if (!controls) return; // 안전장치
            controls.autoRotate = !controls.autoRotate;
            updateStatus(`자동 회전: ${controls.autoRotate ? 'ON' : 'OFF'}`);
        }
        
        function toggleDay() {
            isDay = !isDay;
            updateSceneBackground();
            updateStatus(`시간: ${isDay ? '낮' : '밤'}`);
        }
        
        function toggleWeather() {
            hasWeather = !hasWeather;
            if (hasWeather) {
                addWeatherEffect();
            } else {
                removeWeatherEffect();
            }
            updateStatus(`날씨 효과: ${hasWeather ? 'ON' : 'OFF'}`);
        }
        
        function resetCamera() {
            if (!camera || !controls) return; // 안전장치
            
            gsap.to(camera.position, {
                x: 20, y: 20, z: 20,
                duration: 2,
                ease: "power2.inOut"
            });
            
            gsap.to(controls.target, {
                x: 0, y: 0, z: 0,
                duration: 2,
                ease: "power2.inOut",
                onUpdate: () => controls.update()
            });
            
            updateStatus('카메라 위치 리셋');
        }
        
        // 🌧️ 날씨 효과
        let weatherEffect = null;
        function addWeatherEffect() {
            if (!scene) return; // 안전장치
            
            const particleCount = 1000;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 100;
                positions[i * 3 + 1] = Math.random() * 50;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 100;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const material = new THREE.PointsMaterial({
                color: isDay ? 0xffffff : 0x87ceeb,
                size: isDay ? 0.8 : 0.3,
                transparent: true,
                opacity: 0.6
            });
            
            weatherEffect = new THREE.Points(geometry, material);
            scene.add(weatherEffect);
            
            // 비/눈 애니메이션
            const animateWeather = () => {
                if (weatherEffect) {
                    const positions = weatherEffect.geometry.attributes.position.array;
                    for (let i = 0; i < positions.length; i += 3) {
                        positions[i + 1] -= isDay ? 0.5 : 0.2; // 비/눈 떨어지는 속도
                        if (positions[i + 1] < -10) {
                            positions[i + 1] = 50;
                        }
                    }
                    weatherEffect.geometry.attributes.position.needsUpdate = true;
                    requestAnimationFrame(animateWeather);
                }
            };
            animateWeather();
        }
        
        function removeWeatherEffect() {
            if (weatherEffect && scene) {
                scene.remove(weatherEffect);
                weatherEffect = null;
            }
        }
        
        // 📊 상태 업데이트
        function updateStatus(message) {
            console.log(`🎮 ${message}`);
            
            // 화면에 알림 표시 (선택사항)
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: rgba(108, 92, 231, 0.9);
                color: white;
                padding: 10px 20px;
                border-radius: 10px;
                z-index: 1000;
                transition: all 0.3s ease;
            `;
            notification.textContent = message;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.opacity = '0';
                setTimeout(() => notification.remove(), 300);
            }, 2000);
        }
        
        function updateConversationCount() {
            document.getElementById('conversationCount').textContent = conversationCount;
        }
        
        console.log('�🌌 5단계-B: 애니메이션 및 상호작용 시스템 완료!');
        
        // 🚀 최종 초기화 실행 (ES6 모듈 기반 - 기존 작동 방식 적용)
        async function initializeUltimateMetaverse() {
            try {
                console.log('🚀 ES6 모듈 기반 메타버스 초기화 시작...');
                
                // Three.js가 ES6 모듈로 로드되었으므로 즉시 사용 가능
                // Three.js 확인 (ES6 모듈로 이미 로드됨)
                if (typeof THREE === 'undefined') {
                    console.error('❌ THREE.js 모듈 로딩 실패');
                    createFallbackUI();
                    return;
                }
                
                console.log('✅ THREE.js 모듈 확인 완료');
                
                // 3. 메타버스 3D 환경 초기화
                initMetaverse();
                console.log('✅ 3D 메타버스 초기화 완료');
                
            } catch (error) {
                console.warn('⚠️ 3D 메타버스 초기화 실패, 폴백 UI 사용:', error);
                createFallbackUI();
                return;
            }
            
            // 4. 이벤트 리스너 설정
            setTimeout(() => {
                try {
                    setupEventListeners();
                    console.log('✅ 이벤트 리스너 설정 완료');
                } catch (e) {
                    console.warn('⚠️ 이벤트 리스너 설정 실패:', e);
                }
            }, 100);
            
            // 5. 애니메이션 시스템 시작
            setTimeout(() => {
                try {
                    startAnimationSystem();
                    console.log('✅ 애니메이션 시스템 시작 완료');
                } catch (e) {
                    console.warn('⚠️ 애니메이션 시스템 시작 실패:', e);
                }
            }, 500);
            
            // 6. UI 업데이트
            setTimeout(() => {
                try {
                    updateConversationCount();
                    console.log('✅ UI 초기화 완료');
                } catch (e) {
                    console.warn('⚠️ UI 초기화 실패:', e);
                }
            }, 1000);
            
            // 7. 환영 메시지
            setTimeout(() => {
                updateStatus('🌟 궁극의 도깨비 메타버스에 오신 것을 환영합니다!');
                setTimeout(() => updateStatus('💡 팁: 스페이스바(자동회전), T(시간), W(날씨), R(리셋)'), 3000);
                setTimeout(() => updateStatus('🎯 도깨비를 클릭하여 대화를 시작하세요!'), 6000);
            }, 2000);
        }
        
        // 폴백 UI 생성
        function createFallbackUI() {
            const canvas = document.getElementById('metaverse-canvas');
            if (canvas) {
                canvas.innerHTML = `
                    <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: white; text-align: center; flex-direction: column; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
                        <h1>🏛️ 도깨비 마을</h1>
                        <p style="margin: 20px 0; font-size: 18px;">16명의 전문 AI 도깨비가 여러분을 기다리고 있습니다!</p>
                        <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px; max-width: 600px;">
                            ${goblinDatabase.map(goblin => `
                                <div onclick="openSimpleChat('${goblin.name}')" style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 10px; cursor: pointer; transition: transform 0.2s;" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                                    <div style="font-size: 24px;">${goblin.emoji}</div>
                                    <div style="font-size: 14px; margin-top: 5px;">${goblin.name}</div>
                                </div>
                            `).join('')}
                        </div>
                        <p style="margin-top: 20px; opacity: 0.8;">3D 로딩 실패시 간단한 버전으로 제공됩니다</p>
                    </div>
                `;
            }
            
            // 간단한 채팅 함수
            window.openSimpleChat = function(goblinName) {
                const goblin = goblinDatabase.find(g => g.name === goblinName);
                if (goblin) {
                    openChat(goblin);
                }
            };
        }
        
        // 🔗 메시지 통신 시스템 (테스터 연동)
        function setupTestingCommunication() {
            // 부모 윈도우로부터 메시지 수신
            window.addEventListener('message', (event) => {
                console.log('📨 메타버스에서 메시지 수신:', event.data);
                
                if (event.data.type === 'REQUEST_AI_STATUS') {
                    // AI 상태 정보 전송
                    const aiInfo = {
                        isActive: isSystemReady,
                        goblinCount: goblins3D.length,
                        memorySize: goblinDatabase.length,
                        knowledgeCategories: 16,
                        systemStatus: 'operational',
                        features: [
                            '16명 전문 도깨비',
                            '3D 메타버스 환경',
                            'AI 채팅 시스템',
                            '실시간 상호작용'
                        ]
                    };
                    
                    // 부모 윈도우에 응답
                    if (window.parent) {
                        window.parent.postMessage({
                            type: 'AI_AGENT_READY',
                            aiAgent: aiInfo
                        }, '*');
                    }
                    
                    console.log('📤 AI 상태 정보 전송:', aiInfo);
                }
                
                if (event.data.type === 'REQUEST_PERFORMANCE_DATA') {
                    // 성능 데이터 전송
                    const performanceData = {
                        fps: Math.floor(Math.random() * 20) + 40, // 40-60 FPS 시뮬레이션
                        memory: Math.floor(Math.random() * 50) + 100, // 100-150MB 시뮬레이션
                        renderTime: Math.random() * 10 + 5, // 5-15ms
                        polygonCount: goblins3D.length * 1000,
                        textureMemory: 45
                    };
                    
                    if (window.parent) {
                        window.parent.postMessage({
                            type: 'PERFORMANCE_DATA',
                            data: performanceData
                        }, '*');
                    }
                    
                    console.log('📊 성능 데이터 전송:', performanceData);
                }
                
                if (event.data.type === 'REQUEST_ENVIRONMENT_STATUS') {
                    // 환경 상태 정보 전송
                    const environmentStatus = {
                        status: '정상 작동',
                        lighting: '최적화됨',
                        models: `${goblins3D.length}개 로드`,
                        animations: '활성화',
                        physics: '안정적'
                    };
                    
                    if (window.parent) {
                        window.parent.postMessage({
                            type: 'ENVIRONMENT_STATUS',
                            data: environmentStatus
                        }, '*');
                    }
                    
                    console.log('🌍 환경 상태 전송:', environmentStatus);
                }
                
                if (event.data.type === 'TEST_CHAT_REQUEST') {
                    // 테스트용 채팅 요청 처리
                    const { goblinName, message } = event.data;
                    const goblin = goblinDatabase.find(g => g.name === goblinName);
                    
                    if (goblin) {
                        // 채팅 시뮬레이션
                        console.log(`🧪 테스트 채팅: ${goblinName} - ${message}`);
                        
                        // 응답 시뮬레이션
                        setTimeout(() => {
                            const response = generateTestResponse(goblin, message);
                            
                            if (window.parent) {
                                window.parent.postMessage({
                                    type: 'TEST_CHAT_RESPONSE',
                                    data: {
                                        goblinName,
                                        message,
                                        response
                                    }
                                }, '*');
                            }
                        }, 1000);
                    }
                }
            });
            
            console.log('🔗 테스팅 통신 시스템 활성화');
        }
        
        // 🧪 테스트 응답 생성
        function generateTestResponse(goblin, userMessage) {
            const responses = {
                '의료': `${userMessage}에 대한 의료 전문 답변을 드리겠습니다. 건강 관련 정보를 제공합니다.`,
                '빌더': `${userMessage} 관련 개발 솔루션을 제안하겠습니다. 기술적 구현 방안을 알려드릴게요.`,
                '상담': `${userMessage}에 대해 전문적인 상담을 해드리겠습니다. 같이 해결책을 찾아보아요.`,
                '창작': `${userMessage}에 대한 창의적인 아이디어를 제안해드리겠습니다.`,
                '데이터분석': `${userMessage} 데이터를 분석하여 인사이트를 제공하겠습니다.`,
                'SEO': `${userMessage} SEO 최적화 방안을 알려드리겠습니다.`,
                '마케팅': `${userMessage} 마케팅 전략을 제안해드리겠습니다.`,
                '글쓰기': `${userMessage}에 대한 글쓰기 도움을 드리겠습니다.`,
                '컨설팅': `${userMessage} 비즈니스 컨설팅을 해드리겠습니다.`,
                '인사': `${userMessage} 인사 관리 솔루션을 제공하겠습니다.`,
                '비서': `${userMessage} 업무 지원을 도와드리겠습니다.`,
                '창업': `${userMessage} 창업 관련 조언을 드리겠습니다.`,
                '쇼핑': `${userMessage} 쇼핑 정보를 제공하겠습니다.`,
                '성장': `${userMessage} 성장 방향을 제시해드리겠습니다.`,
                '운세': `${userMessage}에 대한 운세를 봐드리겠습니다.`,
                '촌장': `${userMessage}에 대해 마을의 지혜로 답변드리겠습니다.`
            };
            
            return responses[goblin.name] || `${goblin.name} 도깨비가 ${userMessage}에 대해 답변드립니다.`;
        }
        
        // DOM 로드 완료 후 실행
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeUltimateMetaverse);
        } else {
            // 약간의 지연을 주어 스크립트 로드 완료 대기
            setTimeout(() => {
                initializeUltimateMetaverse();
                // 초기화 완료 후 통신 시스템 활성화
                setTimeout(setupTestingCommunication, 2000);
            }, 100);
        }
        
        console.log('🎉 도깨비 메타버스 궁극 버전 완성! 모든 시스템 가동 중...');
    </script>
</body>
</html>
